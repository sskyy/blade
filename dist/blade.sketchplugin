// Sketch blade (ctrl  command b)

/**
 * Authorized by Jiamiu, all rights reserved.
 */

/*
This is a port to JSTalk of <https://github.com/leighmcculloch/AppSandboxFileAccess>

Here's the original license for AppSandboxFileAccess:

## License

Copyright (c) 2013, Leigh McCulloch All rights reserved.

BSD-2-Clause License: http://opensource.org/licenses/BSD-2-Clause

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

- Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var AppSandboxFileAccessPersist = {
  keyForBookmarkDataForURL: function(url) {
    log("AppSandboxFileAccessPersist.keyForBookmarkDataForURL("+url+")")
    var urlStr = [url absoluteString];
    log("> " + [NSString stringWithFormat:@"bd_%1$@", urlStr])
    return [NSString stringWithFormat:@"bd_%1$@", urlStr];
  },
  bookmarkDataForURL: function(url) {
    log("AppSandboxFileAccessPersist.bookmarkDataForURL('"+ url +"')")
    var defaults = [NSUserDefaults standardUserDefaults];

    // loop through the bookmarks one path at a time down the URL
    var subUrl = url;
    while ([subUrl path].length() > 1) { // give up when only '/' is left in the path
      var key = AppSandboxFileAccessPersist.keyForBookmarkDataForURL(subUrl);
      var bookmark = [defaults dataForKey:key];
      if (bookmark) { // if a bookmark is found, return it
        return bookmark;
      }
      subUrl = [subUrl URLByDeletingLastPathComponent];
    }
    // no bookmarks for the URL, or parent to the URL were found
    return nil;
  },
  setBookmarkData: function(data, url) {
    log("AppSandboxFileAccessPersist.setBookmarkData")
    log("data: " + data)
    log("URL: " + url)
    var defaults = [NSUserDefaults standardUserDefaults];
    var key = AppSandboxFileAccessPersist.keyForBookmarkDataForURL(url);
    [defaults setObject:data forKey:key];
  }
}

var AppSandboxFileAccess = {
  init: function(opts){
    this.message = opts.message || "Please authorize Sketch to write to this folder. You will only need to do this once."
    this.prompt = opts.prompt || "Authorize",
    this.title = opts.title || "Sketch Authorization"
    return this;
  },
  askPermissionForUrl: function(url) {
    log("AppSandboxFileAccess.askPermissionForUrl("+url+")")
    // this url will be the url allowed, it might be a parent url of the url passed in
    var allowedUrl;

    // create delegate that will limit which files in the open panel can be selected, to ensure only a folder
    // or file giving permission to the file requested can be selected
    // AppSandboxFileAccessOpenSavePanelDelegate *openPanelDelegate = [[AppSandboxFileAccessOpenSavePanelDelegate alloc] initWithFileURL:url];

    // check that the url exists, if it doesn't, find the parent path of the url that does exist and ask permission for that
    var fileManager = [NSFileManager defaultManager];
    var path = [url path];
    while (path.length() > 1) { // give up when only '/' is left in the path or if we get to a path that exists
      if ([fileManager fileExistsAtPath:path]) {
        break;
      }
      path = [path stringByDeletingLastPathComponent];
    }
    log("Looks like we have a winner: " + path)
    url = [NSURL fileURLWithPath:path];

    // display the open panel
    var openPanel = [NSOpenPanel openPanel];
    [openPanel setMessage:this.message];
    [openPanel setPrompt:this.prompt];
    [openPanel setTitle:this.title];
    // [openPanel setDelegate:openPanelDelegate];
    [openPanel setCanCreateDirectories:false];
    [openPanel setCanChooseFiles:true];
    [openPanel setCanChooseDirectories:true];
    [openPanel setAllowsMultipleSelection:false];
    [openPanel setShowsHiddenFiles:false];
    [openPanel setExtensionHidden:false];
    [openPanel setDirectoryURL:url];
    [[NSApplication sharedApplication] activateIgnoringOtherApps:true];
    var openPanelButtonPressed = [openPanel runModal];
    if (openPanelButtonPressed == NSFileHandlingPanelOKButton) {
      allowedUrl = [openPanel URL];
    }
    return allowedUrl;
  },
  persistPermissionPath: function(path) {
    this.persistPermissionURL([NSURL fileURLWithPath:path]);
  },
  persistPermissionURL: function(url) {
    log("AppSandboxFileAccess.persistPermissionURL("+url+")")
    // store the sandbox permissions
    url = [[url URLByStandardizingPath] URLByResolvingSymlinksInPath]
    var bookmarkData = [url bookmarkDataWithOptions:NSURLBookmarkCreationWithSecurityScope
                           includingResourceValuesForKeys:nil
                           relativeToURL:nil
                           error:null];
    if (bookmarkData) {
      AppSandboxFileAccessPersist.setBookmarkData(bookmarkData, url);
    }
  },
  accessFilePath_withBlock_persistPermission: function(path, block, persist) {
    log("AppSandboxFileAccess.accessFilePath_withBlock_persistPermission")
    log("path: " + path)
    return AppSandboxFileAccess.accessFileURL_withBlock_persistPermission([NSURL fileURLWithPath:path], block, persist);
  },
  accessFileURL_withBlock_persistPermission: function(fileUrl, block, persist) {
    log("AppSandboxFileAccess.accessFileURL_withBlock_persistPermission")
    log("fileUrl: " + fileUrl)
    log("block: " + block)
    log("persist: " + persist)
    var allowedUrl = false;
    // standardize the file url and remove any symlinks so that the url we lookup in bookmark data would match a url given by the askPermissionForUrl method
    var fileUrl = [[fileUrl URLByStandardizingPath] URLByResolvingSymlinksInPath];
    // lookup bookmark data for this url, this will automatically load bookmark data for a parent path if we have it
    var bookmarkData = AppSandboxFileAccessPersist.bookmarkDataForURL(fileUrl);

    if (bookmarkData) {
      log("Bookmark data found")
      // resolve the bookmark data into an NSURL object that will allow us to use the file
      var bookmarkDataIsStale;
      allowedUrl = [NSURL URLByResolvingBookmarkData:bookmarkData options:NSURLBookmarkResolutionWithSecurityScope|NSURLBookmarkResolutionWithoutUI relativeToURL:nil bookmarkDataIsStale:bookmarkDataIsStale error:null];
      // if the bookmark data is stale, we'll create new bookmark data further down
      if (bookmarkDataIsStale) {
        bookmarkData = nil;
      }
    } else {
      log("No bookmark data found")
    }

    // if allowed url is nil, we need to ask the user for permission
    if (!allowedUrl) {
      allowedUrl = AppSandboxFileAccess.askPermissionForUrl(fileUrl);
      if (!allowedUrl) {
        // if the user did not give permission, exit out here
        return false;
      }
    }
    // if we have no bookmark data, we need to create it, this may be because our bookmark data was stale, or this is the first time being given permission
    if (persist && !bookmarkData) {
      AppSandboxFileAccess.persistPermissionURL(allowedUrl);
    }
    // execute the block with the file access permissions
    try {
      [allowedUrl startAccessingSecurityScopedResource];
      block();
    } finally {
      [allowedUrl stopAccessingSecurityScopedResource];
    }
    return true;
  }
}
function in_sandbox(){
  var environ = [[NSProcessInfo processInfo] environment];
  return (nil != [environ objectForKey:@"APP_SANDBOX_CONTAINER_ID"]);
}
var sandboxAccess = AppSandboxFileAccess.init({
  message: "Please authorize Sketch to write to this folder. You will only need to do this once per folder.",
  prompt:  "Authorize",
  title: "Sketch Authorization"
})


if ( in_sandbox()) {
  [[NSApplication sharedApplication] displayDialog:"Please use this plugin with Sketch Beta. You can search 'Sketch Beta' in Google to download it.\n\n(Or manually copy framer.js info the framer folder)." withTitle:"Sketch Framer known bugs"]
}

/**
 * Created by jiamiu on 14-5-19.
 */

var Config = Config || (function(){

    var document_path = [[doc fileURL] path].replace( /\/[^\/]+\.sketch$/,'\/'),
        document_name = [doc displayName].replace(".sketch",""),
        target_folder = document_path + document_name,
        images_folder = target_folder + "/images",
        css_folder = target_folder + "/css",
        js_folder = target_folder + "/js",
        plugin_folder = '/Users/jiamiu/Library/Application\ Support/'
            + [[[NSBundle mainBundle] infoDictionary] objectForKey:'CHApplicationSupportFolderName']
            + '/Plugins'



    return {
        document_path : document_path,
        document_name : document_name,
        target_folder : target_folder,
        images_folder : images_folder,
        js_folder : js_folder,
        css_folder : css_folder,
        plugin_folder : plugin_folder,
        global_scripts : [{
            comment : 'global script : jquery-2.1.1.min.js',
            origin : plugin_folder + '/blade/lib/jquery-2.1.1.min.js',
            src : js_folder + '/jquery-2.1.1.min.js'
        }],
        global_styles : [{
            comment : 'global reset',
            origin : plugin_folder + '/blade/lib/reset.css',
            href : css_folder + '/reset.css'
        }],
        export_img_ext : ".png",
        show_error : true

    }
})()


/* Created by jiamiu on 14-5-19. */

//This file is base on Sam Deane's code, see the original license below

// --------------------------------------------------------------------------
// Miscellaneous Sketch utilities.
//
//  Copyright 2014 Sam Deane, Elegant Chaos. All rights reserved.
//  This source code is distributed under the terms of Elegant Chaos's
//  liberal license: http://www.elegantchaos.com/license/liberal
// --------------------------------------------------------------------------


var Util = Util || (function() {
    var my = {};

    // it's helpful to have somewhere to store values in a way that will persist across invocations of
    // the script, so you can store something on one run, and pick it up again on the next
    // as luck would have it, there's a dictionary associated with each thread, so we can use the main thread's
    // dictionary to keep out persistent values in
    var persistent = [[NSThread mainThread] threadDictionary];

    // an example of something we might want to persist is the contents of the console
    var console = persistent["console"];

    // perform a come code inside a try/catch block, and log out the error if something goes wrong
    my.execute = function(block) {
        try
        {
            block();
        }
        catch (e)
        {
            my.log(e);
        }
    }

    // export the first slice from a doc, as a given kind
    my.export = function(document, kind){
        var slices = [[document currentPage] allSlices];
        if ([slices count] > 0) {
            var slice = slices[0];
            var file_url = [document fileURL];
            var file_name = [[file_url URLByDeletingPathExtension] lastPathComponent];
            var export_folder = [[[file_url URLByDeletingLastPathComponent] URLByDeletingLastPathComponent] URLByAppendingPathComponent:"Exported"]
            var export_url = [[export_folder URLByAppendingPathComponent:file_name] URLByAppendingPathExtension:kind];
            var export_path = [export_url path];
            [document saveArtboardOrSlice:slice toFile:export_path];
            my.log("Exported " + export_path);
        } else {
            my.log("No slices");
        }
    };

    // return the Sketch version number
    // (we fish this out of the main info dictionary for the application)
    my.version = function() {
        var items = my.versionComponents();

        var result = items[0] + "." + items[1];
        if (items[2] != 0)
            result += "." + items[2];

        return result;
    }

    // return the Sketch version number, split into three components
    // (we fish this out of the main info dictionary for the application)
    my.versionComponents = function() {
        var info = [[NSBundle mainBundle] infoDictionary];
        var items = [[(info["CFBundleShortVersionString"]) componentsSeparatedByString:"."] mutableCopy];

        while(items.length() < 3)
            [items addObject:"0"];

        return items;
    }

    // return the main Sketch version number (eg 2 in 2.4.3)
    my.majorVersion = function() {
        var items = my.versionComponents();

        return items[0];
    }

    // return the minor Sketch version number (eg 4 in 2.4.3)
    my.minorVersion = function() {
        var items = my.versionComponents();

        return items[1];
    }

    // return the fix Sketch version number (eg 3 in 2.4.3)
    my.fixVersion = function() {
        var items = my.versionComponents();

        return items[2];
    }

    // return the exact Sketch build number
    // (we fish this out of the main info dictionary for the application)
    my.buildNumber = function() {
        var info = [[NSBundle mainBundle] infoDictionary];
        var result = info["CFBundleVersion"];

        return result;
    }

    // perform an action (in the way that a menu or button typically does)
    // what we're doing here is sending a command (an Objective-C method call)
    // down a chain of objects (the current window,
    // the current document, the application, etc) until one responds
    my.sendAction = function(commandToPerform) {
        try {
            [NSApp sendAction:commandToPerform to:nil from:doc]
        } catch(e) {
            my.log(e)
        }
    };

    // safe implementation of selection, which checks for it being nil
    // (which it can be before the user first selected anything)
    my.selection = function() {
        var selection = doc.selectedLayers();
        if (selection == null) {
            selection = [[NSArray alloc] init]
        }

        return selection;
    };

    // return a persistent window
    // this will make the window the first time it's called, but return the
    // same window next time (even if the next time is during a later execution of the script)
    my.persistentWindow = function(title, persistName, level, setup) {
        var window = persistent[persistName];
        if (window == null) {
            window = my.makeWindow(title, persistName, level, setup);
            persistent[persistName] = window;
        }

        return window;
    }

    // return a persistent panel
    // this will make the window the first time it's called, but return the
    // same window next time (even if the next time is during a later execution of the script)
    my.persistentPanel = function(title, persistName, setup) {
        var window = persistent[persistName];
        if (window == null) {
            window = my.makePanel(title, persistName, setup);
            persistent[persistName] = window;
        }

        return window;
    }

    // make a new window
    // this uses native Cocoa code to create a new window object, and set up various properties on it
    // for more details on NSWindow, see https://developer.apple.com/library/mac/documentation/cocoa/reference/applicationkit/classes/NSWindow_Class/Reference/Reference.html
    my.makeWindow = function(title, autosave, level, setup) {
        var frame = NSMakeRect(0,0,512,128);
        var mask = NSTitledWindowMask + NSClosableWindowMask + NSMiniaturizableWindowMask + NSResizableWindowMask;
        var window = [[NSWindow alloc] initWithContentRect:frame styleMask:mask backing:NSBackingStoreBuffered defer:true];
        window.title = title;
        window.level = level;
        [window setFrameAutosaveName:autosave];

        setup(window);

        [window setReleasedWhenClosed:false];
        [window makeKeyAndOrderFront:nil];

        return window;
    }

    // make a new panel
    // this uses native Cocoa code to create a new panel object, and set up various properties on it
    // for more details on NSPanel, see https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSPanel_Class/Reference/Reference.html
    my.makePanel = function(title, autosave, setup) {
        var frame = NSMakeRect(0,0,512,128);
        var mask = NSTitledWindowMask + NSClosableWindowMask + NSMiniaturizableWindowMask + NSResizableWindowMask + NSUtilityWindowMask;
        var window = [[NSPanel alloc] initWithContentRect:frame styleMask:mask backing:NSBackingStoreBuffered defer:true];
        window.title = title;
        window.floatingPanel = true;
        [window setFrameAutosaveName:autosave];

        setup(window);

        [window setReleasedWhenClosed:false];
        [window makeKeyAndOrderFront:nil];

        return window;
    }

    // make a new log window
    // we use Cocoa here to create a native window, and then we create a scrollview+textview combination
    // as the context, which gives us a scrolling text field
    // as luck would have it, Apple have some documentation describing this process:
    // https://developer.apple.com/library/mac/documentation/cocoa/conceptual/TextUILayer/Tasks/TextInScrollView.html#//apple_ref/doc/uid/20000938-CJBBIAAF
    my.logWindow = function() {
        var window = my.persistentPanel("Console", "LogWindow", function(window) {
            var scrollview = [[NSScrollView alloc] initWithFrame:[[window contentView] frame]];
            var contentSize = [scrollview contentSize];

            [scrollview setBorderType:NSNoBorder];
            [scrollview setHasVerticalScroller:true];
            [scrollview setHasHorizontalScroller:true];
            [scrollview setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];

            var FLT_MAX = 3.40282347e+38;
            var view = [[NSTextView alloc] initWithFrame:NSMakeRect(0, 0, contentSize.width, contentSize.height)];
            [view setMinSize:NSMakeSize(0.0, contentSize.height)];
            [view setMaxSize:NSMakeSize(FLT_MAX, FLT_MAX)];
            [view setVerticallyResizable:true];
            [view setHorizontallyResizable:true];
            [view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
            [[view textContainer] setContainerSize:NSMakeSize(FLT_MAX, FLT_MAX)];
            [[view textContainer] setWidthTracksTextView:false];

            [scrollview setDocumentView:view];
            [window setContentView:scrollview];
            [window makeFirstResponder:view];
        });

        return window;
    };

    // log something to our console window
    // we set the window up first if necessary, then
    // append the log message to the bottom of it and scroll the new line into view
    my.log = function(message) {
        if( !Config.show_error ) return

        if( arguments.length !== 1 ){
            message = Array.prototype.join.call( arguments, ", " )
        }

        var logWindow = my.logWindow();
        [logWindow makeKeyAndOrderFront:nil];

        var text = message;
        //var text = JSON.stringify(message);

        view = [[logWindow contentView] documentView];
        if (console == null)
            console = "";

        var now = new Date();
        var time = now.toLocaleTimeString().split(" ")[0];
        console = console + time + " " + text + "\n";
        [view setString:console];
        log(text);
        persistent["console"] = console;
        [view scrollRangeToVisible: NSMakeRange(view.string.length, 0)];

    };

    my.launch = function(cmd, arguments) {
        var task = [[NSTask alloc] init];
        [task setLaunchPath:cmd];

        if (arguments)
            [task setArguments:arguments];

        var pipe = [NSPipe pipe];
        [task setStandardOutput: pipe];

        var file = [pipe fileHandleForReading];

        [task launch];

        var data = [file readDataToEndOfFile];
        var output = [[NSString alloc] initWithData: data encoding:NSUTF8StringEncoding];

        log(output);
    };

    my.save_file_from_string = function(filename,the_string) {
        var path = [@"" stringByAppendingString:filename],
        str = [@"" stringByAppendingString:the_string];

        if (in_sandbox()) {
            sandboxAccess.accessFilePath_withBlock_persistPermission(filename, function(){
                [str writeToFile:path atomically:true encoding:NSUTF8StringEncoding error:null];
            }, true)
        } else {
            [str writeToFile:path atomically:true encoding:NSUTF8StringEncoding error:null];
        }
    }

    var file_manager = [NSFileManager defaultManager]

    my.create_folders =function ( folders ){
        var i = [folders count] - 1

        for( ; i >-1 ;i-- ){
            [file_manager createDirectoryAtPath:[folders objectAtIndex:i] withIntermediateDirectories:true attributes:nil error:nil];
        }
    }

    my.remove_folder = function( folder ){
        Util.log("removing file at :"+folder)
            [file_manager removeItemAtPath:folder error:nil]
    }

    my.folder_exist = function( folder ){
        return [file_manager fileExistsAtPath:folder]
    }

    my.copy = function ( org, tar ){
        Util.log('copy file:' )
        Util.log( 'from: ' + org )
        Util.log( 'to  : ' + tar )

//        var info  =  [[NSBundle mainBundle] infoDictionary]
//
////        Util.log( info.className())
//
//        for( var i in info ){
//            Util.log("==="+i+"======:")
//            Util.log( [info objectForKey:i])
//        }
        if( [file_manager fileExistsAtPath:org]){
            [file_manager copyItemAtPath:org toPath:tar error:nil];
        }else{
            Util.log('cannot copy,file not exist: '+org)
        }
    }

    my.uniq = (function(){
        var cache = {}

        return function( str ){

            str = str ? str.replace("-","_") : 'noname'

            if( !cache[str] ){
                cache[str] = 1
                return str
            }else{
                cache[str] += 1
                return str + "-" + String(cache[str])
            }
        }
    })()

    var fontManager = [NSFontManager sharedFontManager]

    my.fontWeight = function( font ){
        return fontManager.weightOfFont(font)
    }

    my.toRGBA = function( color ){
        return 'rgba(' + String( color ).replace(/[\(\)]/g,'').split(' ').map(function(v){
            var t = v.split(":"),type = t[0],value=t[1]
            if( type !== 'a' ){
                return Math.round( Number(value) * 256)
            }
            return Number(value)
        }).join(',')+')'
    }

    my.style_to_string = function( styleObj ){
        return join( map( styleObj, function( styles ){
            return join( styles, ":",';\n')
        }), ' {\n', '\n}\n') + '\n}'
    }

    function join( obj, kvSplitor, itemSplitor ){
        if( typeof obj !== 'object') return false

        return  values( map( obj, function(v,k){
            return k+kvSplitor+v
        })).join( itemSplitor )
    }

    function map( obj, cb ){
        var output
        if( Object.prototype.toString.call(obj) == '[object Array]'){
            output = []
        }else if( typeof obj == 'object' ){
            output = {}
        }else{
            return false
        }

        for( var i in obj ){
            if( obj.hasOwnProperty(i) && typeof obj[i] !== 'function' ) {
                output[i] = cb(obj[i], i)
            }
        }
        return output
    }

    function values( obj ) {
        var _values = []
        map(obj,function(v){
            _values.push(v)
        })
        return _values
    }

    function in_array( array, item ){
        var found = false
        for( var i in array ){
            if( item == array[i] ){
                found = true
                break
            }
        }
        return found
    }

    function each( obj, iterator ){
        var i,length

        if( obj.count && obj.className ){
            length = [obj count]

            for( i=0;i<length;i++){
                iterator( [obj objectAtIndex:i], i)
            }
        }else if( Object.prototype.toString.call( obj) == '[object Array]'){
            length = obj.length
            for( i=0;i<length;i++){
                iterator( obj[i],i)
            }
        }else if( typeof obj == 'object'){
            for( i in obj ){
                iterator( obj[i], i)
            }
        }else{
            Util.log("cannot iterator this obj of "+ (obj.className ? obj.className() : (typeof obj)))
        }
    }

    function extend( tar, src ){
        each( src, function( v,k){
            if( Object.prototype.toString.call( v) == '[object Object]'){
                tar[k] = {}
                extend( tar[k], src[k])
            }else if( Object.prototype.toString.call( v) == '[object Array]'){
                tar[k] = []
                extend( tar[k], src[k])
            }else{
                tar[k] = src[k]
            }
        })

        return tar
    }

    function wrap_script( script ){
        if( typeof script == 'object'){
            var arr = script
            for( var i in arr ){
                if( typeof arr[i] == 'function' ){
                    arr[i] = wrap_execute_imediate( String(arr[i] ))
                }
            }
            script = arr.join(';\n')
        }

        return ';(function(){\n' + script + '\n})();\n'
    }

    function render_variables( vars ){
        var output = []
        for( var varName in vars ){
            if( typeof vars[varName] == 'object') {
                //object or array
                output.push(varName + '=' + JSON.stringify(vars[varName]))
            }else if( typeof vars[varName] == 'string'){
                //string
                output.push(varName + '="' + vars[varName]+'"')
            }else{
                //undefined bool number
                output.push( varName + '=' + String(vars[varName]) )
            }
        }
        return "var "+output.join(',')
    }

    function wrap_execute_imediate( functionStr ){
        return ';(' + functionStr +')();\n'
    }

    function script_to_string( scriptObj ){
        return wrap_script([render_variables(scriptObj.vars),scriptObj.body])
    }

    my.join = join
    my.map = map
    my.values = values
    my.in_array = in_array
    my.each = each
    my.extend = extend
    my.wrap_script = wrap_script
    my.render_variables = render_variables
    my.script_to_string =script_to_string

    return my;
}());

/**
 * Created by jiamiu on 14-5-19.
 */

var Dom = Dom || (function(){


    function E( tag ){
        this.tagName= tag || ''
        this.childNodes = []
        this.parentNode = null
        this.innerHTML = ''
        this.id = null
        this.classList = []
        this.style = {}
        this.datas = {}
        this.attrs = {}
    }

    E.prototype.append = function( e ){
        this.childNodes.push(e)
        e.parentNode = this
        return this
    }

    E.prototype.prepend = function( e ){
        this.childNodes.unshift(e)
        e.parentNode = this
        return this
    }

    E.prototype.data = function( name, data ){
        if( data ){
            this.datas[name] = data
            return this
        }else{
            return this.datas[name]
        }
    }

    E.prototype.attr = function( name, data ){
        if( data ){
            this.attrs[name] = data
            return this
        }else{
            return this.attrs[name]
        }
    }

    E.prototype.css = function( name, style ){
        if( style ){
            this.style[name] = style
            return this
        }else{
            return this.style[name]
        }

    }

    E.prototype.find = function( queryString ){
        if( this.childNodes.length == 0) return;

        var output = [],queryArr = queryString.split(" "),
            currentQuery = queryArr.shift()

        Util.each( this.childNodes,function( child){

            if( child.match( currentQuery )){

                if( queryArr.length == 0 ){
                    output.push( child )
                }else{
                    output = output.concat( child.find( queryArr.join(" ")))
                }
            }
        })
        if( output.length !== 0 ){

        }
        return output

    }

    E.prototype.match = function( queryString ){
        var regSelectors = new RegExp('[#\\.\\[][\\w\\d_-]+(\\]|(?=[#\\.\\[])|$)','g'),
            regId = new RegExp('^#'),
            regClass = new RegExp('^\\.'),
            regAttr = new RegExp('^\\['),
            selectors = queryString.match( regSelectors )
        if( selectors ){
            var selector, i, j,found

            for( i in selectors ){
                selector = selectors[i]
                if( regId.test(selector) && this.attr('id') != selector.substr(1) ) return false

                if( regClass.test( selector) ){
                    found = false
                    for( j in this.classList){
                        if( this.classList[j] == selector.substr(1) ){
                            found = true;
                            break;
                        }
                    }
                    if( !found ) return false
                }

                if( regAttr.test( selector) ){
                    found = false
                    for( j in this.attrs ){
                        if( this.attrs[j] == selector.substr(1, selector.length-2)){
                            found = true;
                            break;
                        }
                    }
                    if( !found ) return false
                }
            }
        }

        return true
    }

    E.prototype.addClass = function( className ){
        this.classList.push( className)
        return this
    }

    Object.defineProperty(E.prototype,"outerHTML",{
        get : function(){
            var selfClose = ['input','img','textarea','link']

            if( selfClose.indexOf(this.tagName ) != -1 ){
                return '<' + generate_tag_head(this) + ' />'
            }else{
                if( this.childNodes.length == 0 ){

                    return '<' + generate_tag_head(this) + ' >' + this.innerHTML + '</'+this.tagName + '>'

                }else{

                    var childHTMl = this.childNodes.map(function( child ){
                        return child.outerHTML
                    }).join('')

                    return '<' + generate_tag_head(this) + ' >' + childHTMl + '</'+this.tagName + '>'
                }

            }
        }
    })

    function generate_tag_head( el ){
        var items = [
            el.tagName
        ]

        if( Util.values(el.style).length ){
            items.push('style="' + Util.join(el.style,":",";") + '"')
        }

        if( el.id ){
            items.push( 'id="' + el.id +'"')
        }

        if( Util.values(el.datas).length ){
            items = items.concat( Util.values( Util.map( el.datas, function(v, k){ return 'data-'+k+'="'+v+'"'})))
        }

        if( Util.values(el.attrs).length ){
            items = items.concat( Util.values( Util.map( el.attrs, function(v, k){ return k+'="'+v+'"'})))
        }

        if( el.classList.length ){
            items.push('class="' + el.classList.join(' ')+'"')
        }
//        Util.log( JSON.stringify(items ) )
        return items.join(" ")
    }

    function create(tag){
        return new E(tag)
    }

    return {
        create : create
    }
})()






/**
 * Created by jiamiu on 14-5-19.
 */

var Binding = Binding || (function(){
    var ObjectId = 0

    var bindingImp = {}

    /**
     * @param {string} name
     * @param {function|object} handler - This parameter is just like AngularJS's directive definition object.
     *        Here is an example when pass an object:
     *        {
     *          compose : function(){
     *              // some code here to perform dom transformation
     *          },
     *          link : function(){
     *              //code here to add script
     *          }
     *        }
     *        When pass a function as parameter, the function will be used as `link` function.
     */
    function registry(name, handler){
        if( bindingImp[name] ){
            Util.log( 'you are overwriting binding: ' + name)
        }

        if( typeof handler == 'function'){
            handler = { compose:noop, link : handler }
        }else if( typeof handler =='object'){
            if( !handler.compose ){
                handler.compose = noop
            }
            if( !handler.link ){
                handler.link = noop
            }

        }else{
            Util.log( 'Unacceptable handler for '+name)
            return
        }

        handler.inited = false

        bindingImp[name] = handler

    }

    /**
     * Call all bindings in this layer to do their job.
     *
     * @param {sketch layer} layer
     * @param {object} parentOutputRef - This is a reference to hold process result.
     * @param {object} [bindings] - If bindings was specified, then we will not get from layer name.
     *
     * @return {object|undefined} parentOutputRef - notice that we will always return parentOutputRef.
     */
    function apply_bindings( layer, parentOutputRef, bindings ){
//        Util.log("apply_bindings for "+ layer.name()+" : "+get_kind(layer) + " : " + layer.className() )
        if( !is_layer( layer) ){
            Util.log("please pass a layer as first argument.")
            return
        }

        if( !parentOutputRef ){
            parentOutputRef = {
                dom : Dom.create('body'),
                scripts : [],
                styles : [],
                exportFiles : []
            }

        }

        var outputRef = {
                dom : Dom.create(),
                scripts : [],
                styles : [],
                exportFiles : []
            },
            stopAutoApplyBindingForChildren = false

        // Dom generator may attach scripts for special dom,
        // so we need to pass the output reference as parameter
        generate_dom_by_kind( layer, outputRef )

        //we must append the dom here so compose function can access parent node.
        //notice you can only use dom functions to modify dom, or you will loss reference.
        parentOutputRef.dom.append( outputRef.dom )

        bindings = bindings || get_bindings(layer.name())

        // apply default binding only if no binding specified
        if( !bindings || !Util.values( bindings).length ){
            bindingImp['default']['link']( layer, null,  outputRef )
        }else{
            //compose it first and load external scripts and styles
            Util.each( bindings, function( bindingArgs, bindingName ){
                //load scripts and styles
                if( !bindingImp[bindingName] ){
                    Util.log('Unknown binding: '+ bindingName)
                    return
                }

                if( !bindingImp[bindingName].inited ){
                    if( bindingImp[bindingName]['init'] ){
                        bindingImp[bindingName]['init']()
                    }

                    if( bindingImp[bindingName]['scripts'] ){
                        Util.log("find script for "+bindingName)
                        outputRef.scripts = outputRef.scripts.concat( bindingImp[bindingName]['scripts'] )
                    }
                    //load styles
                    if( bindingImp[bindingName]['styles'] ){
                        outputRef.styles = outputRef.styles.concat( bindingImp[bindingName]['styles'] )
                    }

                    bindingImp[bindingName].inited = true

                }

                if( bindingImp[bindingName].stopAutoApplyBindingForChildren ){
                    Util.log(bindingName+' has stopAutoApplyBindingForChildren')
                    stopAutoApplyBindingForChildren = true
                }

                //compose
                bindingImp[bindingName]['compose']( layer, bindingArgs, outputRef )

                //mark it
                outputRef.dom.attr('binding-'+bindingName,String(bindingArgs))
            })



            Util.log("get bindings"+JSON.stringify( bindings))

            //link it
            Util.each( bindings, function( bindingArgs, bindingName ){
                Util.log("calling binding link function " +  bindingName)
                if( bindingImp[bindingName] ){
                    bindingImp[bindingName]['link']( layer, bindingArgs, outputRef )
                }else{
                    Util.log('Unknown binding: '+ bindingName)
                }
            })
        }

        if( is_folder(layer) && !stopAutoApplyBindingForChildren){
            var layers= [layer layers]
            Util.each( layers, function( subLayer){
                apply_bindings( subLayer, outputRef )
            })
        }

        parentOutputRef.scripts = parentOutputRef.scripts.concat( outputRef.scripts )
        parentOutputRef.styles = parentOutputRef.styles.concat( outputRef.styles )
        parentOutputRef.exportFiles = parentOutputRef.exportFiles.concat( outputRef.exportFiles )

        return parentOutputRef
    }

    function get_bindings( name ){
        var matches = name.match(/\[([\w\d%_,-:=]*)\]/g),
            bindings = {}

        if( matches ){
            for( var i in matches ){
                var tmp = matches[i].substring(1,matches[i].length-1).split("="),
                    bindingName = tmp[0],
                    bindingArgs = tmp[1] ? tmp[1].split(",") : [true]

                bindings[bindingName] = bindingArgs
            }
        }
        return bindings
    }


    var domGenerators = {}

    function register_dom_generator(name, handler){
        domGenerators[name] = (typeof handler =='object') ? handler : {dom:handler,css:noop}
    }

    function generate_dom_by_kind( layer, outputRef ){

        var kind = get_kind( layer),generatorName = domGenerators[kind]? kind : 'default'
        Util.log("generate dom for " + kind)

        domGenerators[generatorName].dom( layer, outputRef )
        domGenerators[generatorName].css( outputRef.dom, layer)

        outputRef.dom.data('sketch-kind', kind )
        outputRef.dom.data('title', layer.name())
    }

    function setup_rect_for_dom( dom, layer ){
        dom.style.position = "absolute"
        if( get_kind(layer.parentGroup()) == 'LayerGroup' ){
            dom.style.left = layer.absoluteRect().rulerX() - layer.parentGroup().absoluteRect().rulerX()
            dom.style.top = layer.absoluteRect().rulerY() - layer.parentGroup().absoluteRect().rulerY()
        }else{
            dom.style.left = layer.absoluteRect().rulerX()
            dom.style.top = layer.absoluteRect().rulerY()
        }

        dom.style.width =  layer.absoluteRect().width()
        dom.style.height =  layer.absoluteRect().height()
        if( !layer.isVisible()){
            dom.css('display','none')
        }
    }

    function sanitize_filename(name){
        return name.replace(/(\s|:|\/)/g ,"_").replace(/__/g,"_").replace("*","").replace("+","").replace("@@hidden","");
    }



    function get_kind( layer) {
        var _class = layer.className(),
            _kind = "Other",
            _path;
        if ( _class == "MSTextLayer" ) { // text layer
            _kind = "Text";
        } else if ( _class == "MSArtboardGroup") { // text layer
            _kind = "Artboard"
        } else if ( _class == "MSSliceLayer") { // text layer
            _kind = "Slice";
        } else if (_class == "MSBitmapLayer" ) { // text layer
            _kind = "Bitmap";
        } else if (_class == "MSShapeGroup" ) { // group layer or shape layer
            if( layer.children().count() == 2 ){
                var _lay = layer.children()[0],
                    _class1 = _lay.className().toString(),
                    _isSpecificShape1 = /^MS\w*Shape$/.test(_class1)


                if (_class1 == "MSShapePathLayer") { // shape path
                    _path = _lay.path(); // get the path on the layer
                    if (_path.isLine()) { // check with the path method
                        _kind = "Line";
                    }else{
                        _kind = "Vector"
                    }
                } else if (_isSpecificShape1) {
                    _kind = _class1.replace("MS", "").replace("Shape", "");
                }
            }else{
                _kind = "ShapeGroup"
            }

        }else if( _class== "MSLayerGroup" ){
            _kind  = "LayerGroup"
        }

        return _kind;
    }

    function generate_id(){
        return '_object_' + ObjectId++
    }

    function concat_child_process_result( current, child){
        if( child.dom ){
            current.dom.append(child.dom)
        }
        current.scripts = current.scripts.concat( child.scripts )
        current.styles = current.styles.concat( child.styles)
    }

    function get_styles( layer ){
        var styles = {},
            borders = layer.style.borders().array(),
            fills = layer.style.fills().array(),
            shadows =layer.style.shadows().array(),
            innerShadows =layer.style.innerShadows().array()

        //TODO
        return styles
    }



    function is_group(layer) {
        return [layer isMemberOfClass:[MSLayerGroup class]] || [layer isMemberOfClass:[MSArtboardGroup class]]
    }

    function is_folder( layer ){
        return layer.className().toString() == 'MSLayerGroup'
    }

    function is_array( layer ){
        return [layer isMemberOfClass:[MSArray class]]

    }

    function is_layer( layer ){
        if( !layer.className ) return false

        var classes = ['MSLayerGroup','MSShapeGroup','MSArtboardGroup','MSTextLayer','MSBitmapLayer','MSShapePathLayer','MSShapePath']
        return Util.in_array( classes, layer.className().toString() )
    }



    function noop(){}

    return {
        apply_bindings : apply_bindings,
        registry : registry,
        get_bindings : get_bindings,
        generate_dom_by_kind : generate_dom_by_kind,
        generate_id : generate_id,
        concat_child_process_result : concat_child_process_result,
        register_dom_generator : register_dom_generator,
        sanitize_filename : sanitize_filename,
        is_group : is_group,
        is_array : is_array,
        is_folder : is_folder,
        get_kind : get_kind,
        setup_rect_for_dom:setup_rect_for_dom,
        get_styles : get_styles,
        domGenerators : domGenerators
    }
})()



/**
 * Created by jiamiu on 14-5-21.
 */


Binding.register_dom_generator('LayerGroup',function(layer, outputRef){
    outputRef.dom =  Dom.create('div')
    Binding.setup_rect_for_dom( outputRef.dom, layer )

})

Binding.register_dom_generator('Text',{
    dom :function(layer, outputRef){

        var needExport = false
        if( layer.style().borders().array().count() !== 0
            || layer.style().fills().array().count()
            ){
            needExport = true
        }


        if( !needExport ){
            var dom = Dom.create('p')
            //TODO browsers has different strategy to calculate the width of space with Sketch.
            dom.innerHTML = layer.stringValue()
        }else{
            var dom = Dom.create('img'),
                filename = Util.uniq( Config.images_folder + "/" + Binding.sanitize_filename(layer.name()) ),
                ext = Config.export_img_ext

            dom.attr('src', filename+ext)
            outputRef.exportFiles.push( {layer : layer, target : filename+ext})
        }

        Binding.setup_rect_for_dom( dom, layer )
        outputRef.dom = dom



    },
    css :function(dom, layer){
        if( dom.tagName == 'img' ) return

        Util.extend( dom.style,{
            "font-size" : layer.fontSize(),
            "letter-spacing" : layer.characterSpacing(),
            "line-height" :  layer.lineSpacing() + 'px'
        })

        dom.style['color'] = 'rgba(' + String(layer.textColor()).replace(/[\(\)]/g,'').split(' ').map(function(v){
            var t = v.split(":"),type = t[0],value=t[1]
            if( type !== 'a' ){
                return Math.round( Number(value) * 256)
            }
            return Number(value)
        }).join(',')+')'


        var align = ['left','right','center','justify']
        dom.style['text-align'] = align[layer.textAlignment()] ? align[layer.textAlignment()] : 'inherit'

        //fix browser and Sketch line-height diffrence
        dom.style['margin-top'] = (parseInt( dom.style['line-height'] ) - parseInt( layer.fontSize() ) ) + "px"

        dom.style['white-space'] = 'pre'

        //NOT SUPPORT font-style NOW
        var font = layer.font()
        dom.style['font-family'] = "'"+font.familyName()+"'"
        dom.style['font-weight'] = Number(Util.fontWeight( font) ) *100

        //TODO: deal with font fill

    }
})

//due to Sketch api issue, we can not generate div for every Rectangle
Binding.register_dom_generator('Rect',{
    dom:function(layer, outputRef){
        //Rectangle is the shape which will not export as a image but generate a div.

        var needExport = false,
            borders = layer.style().borders().array(),
            fills = layer.style().fills().array(),
            i= 0,fillsCount = fills.count(),
            dom

        if( borders.count() > 1 ){
            Util.log("borders count > 1")
            needExport = true
        }

        for( ;i<fillsCount; i++){
            if( fills[i].fillType == 4  ){
                Util.log("fillType == 4")

                needExport= true;
                break;
            }
        }

        if( needExport ){
            dom = Dom.create('img')
            var  filename = Util.uniq( Config.images_folder + "/" + Binding.sanitize_filename(layer.name()) ),
                ext = Config.export_img_ext

            dom.attr('src', filename+ext)
            outputRef.exportFiles.push( {layer : layer, target : filename+ext})
        }else{
            dom = Dom.create('div')
        }

        Binding.setup_rect_for_dom( dom, layer )
        outputRef.dom = dom
    },
    css : function(dom, layer) {
        if( dom.tagName == "img") return

        var borders = layer.style().borders().array(),
            fills = layer.style().fills().array(),
            shadows = layer.style().shadows(),
            innerShadows = layer.style().innerShadows()

        if( borders.count() == 1 && borders.objectAtIndex(0).isEnabled()){
            dom.style['border'] = borders.objectAtIndex(0).thickness() +"px solid " + Util.toRGBA( borders.objectAtIndex(0).color() )
        }
        if( fills.count() > 0 ){
            var backgrounds = []
            Util.each( fills, function(fill){
                if( fill.isEnabled() == 1 ){
                    backgrounds.push( Util.toRGBA( fill.color()))
                }
            })
            backgrounds.length && ( dom.style['background'] = backgrounds.join(',') )
        }

        if( shadows.count() + innerShadows.count() > 0 ){
            var shadowStyles = []
            Util.each( shadows, function( shadow){
                if( !shadow.isEnabled() ) return

                shadowStyles.push(
                        [shadow.offsetX(),shadow.offsetY(),shadow.blurRadius(),shadow.spread()].map(function(i){
                            return i+"px"
                        }).join(' ') + " " + Util.toRGBA( shadow.color())
                )
            })

            Util.each( innerShadows, function( innerShadow){
                if( !innerShadow.isEnabled() ) return ;

                shadowStyles.push(
                        "inset " + [innerShadow.offsetX(),innerShadow.offsetY(),innerShadow.blurRadius(),innerShadow.spread()].map(function(i){
                        return i+"px"
                    }).join(' ') + " " + Util.toRGBA( innerShadow.color())
                )
            })
            shadowStyles.length && ( dom.style['box-shadow'] = shadowStyles.join(','))
        }
    }
})

Binding.register_dom_generator('default',function(layer,outputRef){
    var dom = Dom.create('img'),
        filename = Util.uniq( Config.images_folder + "/" + Binding.sanitize_filename(layer.name()) ),
        ext = Config.export_img_ext



    dom.attr('src', filename+ext)
    //export it
    outputRef.exportFiles.push( {layer : layer, target : filename+ext})

    Binding.setup_rect_for_dom( dom, layer )
    outputRef.dom = dom
})



/**
 * Created by jiamiu on 14-6-5.
 */

Binding.registry('a',{
    compose: function(  layer, args, outputRef  ){
        var dom = outputRef.dom,
            id = dom.attr('id') || Binding.generate_id(),
            href = args.pop()


        dom.tagName = 'a'

        if( !dom.attr('id') ){
            dom.attr('id', id)
        }

        //due to JSTalk RegExp issue
        if( href.substr(0,6) !== "http:/" || href.substr(0,6) !=="https:"){
            href = 'http:\/\/' +href
        }

        dom.attr('href', href)

        var style = {
            comment : "dynamically generated for tag a",
            style : {}
        }
        style.style['#'+id] = {}
        style.style['#'+id+":hover"] = {}

        if( Binding.get_kind( layer ) !== 'LayerGroup' ){
            Binding.domGenerators['Text'].css( dom, layer )
        }else{
            var layers = [layer layers]

            Util.each( layers, function( subLayer){

                var bindings = Binding.get_bindings(subLayer.name()),
                    binding = Util.values( bindings).pop(),
                    fakeDom,


                fakeDom = Dom.create('div')

                    //use generator to help use with css
                    Binding.domGenerators['Text'].css( fakeDom, subLayer )

                    if( !dom.innerHTML ){
                        dom.innerHTML = subLayer.stringValue()
                    }

                Util.extend(style.style['#'+id+(binding?':'+binding:'')] , fakeDom.style)
            })
        }

        // set position for text
        dom.style['cursor'] = 'pointer'
        dom.style['text-decoration'] = 'none'
        outputRef.dom = dom
    },
    //we will take the children from here
    stopAutoApplyBindingForChildren : true
})
/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-6-5.
 */

Binding.registry('btn',{
    compose: function(  layer, args, outputRef  ){
        var dom = outputRef.dom,
            layers = [layer layers],
            id,textPosition={},rectPosition={}

        if( dom.attr('id') ){
            id = dom.attr('id')
        }else{
            id = Binding.generate_id()
            dom.attr('id', id)
        }

        dom.tagName = 'a'
        dom.attr('type','text')

        var style = {
            comment : "dynamically generated for button",
            style : {}
        }
        style.style['#'+id] = {}
        style.style['#'+id+":hover"] = {}

        Util.each( layers, function( subLayer){

            var bindings = Binding.get_bindings(subLayer.name()),
                fakeDom

            fakeDom = Dom.create('div')

            if( Binding.get_kind( subLayer) == 'Text'){
                //use generator to help use with css
                Binding.domGenerators['Text'].css( fakeDom, subLayer )

                if( !dom.innerHTML ){
                    dom.innerHTML = subLayer.stringValue()
                    textPosition.x = subLayer.absoluteRect().rulerX()
                    textPosition.y = subLayer.absoluteRect().rulerY()
                }

            }else if( Binding.get_kind(subLayer) == 'Rectangle'){
                Binding.domGenerators['Rect'].css( fakeDom, subLayer )

                outputRef.styles.push( style )

                if( !rectPosition.x ){
                    rectPosition.x = subLayer.absoluteRect().rulerX()
                    rectPosition.y = subLayer.absoluteRect().rulerY()
                }
            }

            Util.extend(style.style['#'+id+(bindings['hover']?':hover':'')] , fakeDom.style)

        })

        // set position for text
        dom.style['padding-top'] = String(textPosition.y - rectPosition.y) + 'px'
        dom.style['padding-left'] = String(textPosition.x - rectPosition.x) + 'px'
        dom.style['box-sizing'] = 'border-box'
        dom.style['cursor'] = 'pointer'
        dom.style['display'] = 'inline-block'
        outputRef.dom = dom
    },
    //we will take the children from here
    stopAutoApplyBindingForChildren : true
})
/**
 * Created by jiamiu on 14-5-19.
 */

Binding.registry('case',{
    scripts : [{
        'origin' : Config.plugin_folder + '/blade/bindings/case/binding-case.js',
        'src' : Config.js_folder +'/binding-case.js'
    }],
    styles:[{
        'origin' : Config.plugin_folder + '/blade/bindings/case/binding-case.css',
        'href' : Config.css_folder + '/binding-case.css'
    }],
    init: function(){
        /* this method will only be called when this binding first be used.*/
    },
    compose: function(  layer, args, outputRef  ){
        var controllerClass = 'binding-case-controller',
            caseClass = 'binding-case',
            casesClass = 'binding-cases',
            controllersClass= controllerClass + 's',
            controllersSelector = '['+controllersClass+']',
            bindings = Binding.get_bindings(layer.name()),
            id = bindings['id'] ? bindings['id'][0] : Binding.generate_id()


        //1. generator a controller for current case
        if( outputRef.dom.parentNode.find(controllersSelector).length ==0 ){
            outputRef.dom.parentNode.append(
                Dom.create('div').attr(controllersClass,controllersClass).addClass(controllersClass) )

            //give parent a class by the way
            outputRef.dom.parentNode.addClass(casesClass)
        }

        var controller = Dom.create('div')
            .attr('data-case-id',id)
            .attr(controllerClass,controllerClass)
            .addClass(controllerClass)
        controller.innerHTML = args[0]

        outputRef.dom.parentNode.find(controllersSelector)[0].append( controller )

        //2. dealing with current case
        if( !outputRef.dom.attr('id') ){
            outputRef.dom.attr('id',id)
        }
        outputRef.dom.addClass( caseClass)
    }
})
/**
 * Created by jiamiu on 14-6-9.
 */

Binding.registry('center',{
    /**
     *
     * @param layer
     * @param args Current support 'v' : vertical, 'h' : horizon, 'v,h' : both.
     * @param outputRef
     */
    link: function(  layer, args, outputRef  ){
        var dom = outputRef.dom,
            id = dom.attr('id') || Binding.generate_id(),
            type

        while( type = args.pop() ){
            if( type == 'h' ){

                dom.style['position'] = 'relative'
                dom.style['margin-left'] = 'auto'
                dom.style['margin-right'] = 'auto'

            }else if( type =='v' ){

                //use script

            }
        }

    }
})
/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-21.
 */

Binding.registry('default',function(  layer, args, outputRef  ){
    //we do nothing!
})
/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

Binding.registry('hover',function(  layer, args, outputRef  ){
//    if( !Binding.is_group( layer) ){
//        Util.log('[hover] :' + layer.name() +' is not group.')
//        return
//    }
//
//    //1.deal with current layer
//    var bindings = Binding.get_bindings(layer.name()),
//        id = bindings['id'] ? bindings['id'][0] : Binding.generate_id()
//
//
//    if( !outputRef.dom.attr('id') ){
//        outputRef.dom.attr('id',id)
//    }
//
//    //2.deal with children who has binding of [onHover]
//    var subIds = [],layers = [layer layers]
//    Util.each( layers, function( subLayer, i ){
//
//        var subBindings = Binding.get_bindings(subLayer.name()),
//            subId = subBindings['id'] ? subBindings['id'][0] : Binding.generate_id()
//
//        if( !subBindings['onHover'] ){
//            //normal layer
//            if( !outputRef.dom.childNodes[i] ){
//                Binding.apply_bindings( subLayer, outputRef )
//            }
//
//        }else{
//            delete subBindings['onHover']
//
//            //3.generate the children with rest bindings
//            Util.log("==sublayer : " + subLayer)
//
//            if( !outputRef.dom.childNodes[i] ){
//                Binding.apply_bindings( subLayer, outputRef , subBindings )
//            }
//
//            if( !outputRef.dom.childNodes[i].attr('id') ){
//                outputRef.dom.childNodes[i].attr('id',subId)
//            }
//
//            subIds.push(subId)
//
//            //4.output hover script
//            outputRef.scripts.push({
//                comment : 'hover script for '+layer.name(),
//                script :{
//                    vars : {id:id,subIds:subIds},
//                    body : function(){
//                        $.each(subIds,function(k,subId){
//                            $('#'+subId).hide()
//                        })
//
//                        $('#'+id).hover(function(){
//                            $.each(subIds,function(k,subId){
//                                $('#'+subId).show()
//                            })
//                        },function(){
//                            $.each(subIds,function(k,subId){
//                                $('#'+subId).hide()
//                            })
//                        })
//                    }
//                }
//            })
//        }
//
//    })

})
/**
 * Created by jiamiu on 14-5-19.
 */

Binding.registry('ignore',{
    stopAutoApplyBindingForChildren : true
})
/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-6-5.
 */

Binding.registry('text',{
    compose: function(  layer, args, outputRef  ){
        var dom = outputRef.dom,
            layers = [layer layers]

        dom.tagName = 'input'
        dom.attr('type','text')

        Util.each( layers, function( subLayer ){
            if( Binding.get_kind( subLayer) =='Text' ){
                dom.attr('placeholder', subLayer.stringValue() )
                dom.style['font-size'] = subLayer.fontSize()
                dom.style['color'] = Util.toRGBA(subLayer.textColor())

            }else if(Binding.get_kind( subLayer) =='Rectangle'){
                //get background and border
                var border = subLayer.style().borders().array()[0],
                    fill = subLayer.style().fills().array()[0]

                dom.style['border'] = [border.thickness(),'solid', Util.toRGBA(border.color())].join(' ')
                dom.style['background'] = Util.toRGBA(fill.color())

                dom.style['line-height']= dom.style['height'] + "px"
                dom.style['outline']= 'none'
                dom.style['box-sizing']= 'border-box'
                dom.style['padding']= '0 4px'
            }
        })


        outputRef.dom = dom
    },
    //we will take the children from here
    stopAutoApplyBindingForChildren : true
})
/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-6-9.
 */

Binding.registry('width',{
    compose: function(  layer, args, outputRef  ){
        var dom = outputRef.dom,
            id = dom.attr('id') || Binding.generate_id(),
            width = args.pop()

        dom.style['width'] = width

    }
})

/*
//Import the variables and complain if they are undefined
#import 'blade/config.js'
#import 'blade/sandbox.js'
#import 'blade/util.js'
#import 'blade/binding.js'
#import 'blade/dom.js'

//Import dom generators
#import 'blade/dom_generators.js'

//Import all bindings
#import 'blade/bindings/default.js'
#import 'blade/bindings/ignore.js'
#import 'blade/bindings/hover.js'
#import 'blade/bindings/case.js'
#import 'blade/bindings/text.js'
#import 'blade/bindings/button.js'
#import 'blade/bindings/a.js'
#import 'blade/bindings/center.js'
#import 'blade/bindings/width.js'
*/


function export_as_img( layer, filename ){
  // Actual writing of asset
  var slice,
    rect = [layer rectByAccountingForStyleSize:[[layer absoluteRect] rect]]


  slice = [[MSSliceMaker slicesFromExportableLayer:layer inRect:rect] firstObject]
  slice.page = [[doc currentPage] copyLightweight]
  slice.format = "png"

//  Util.log(" writing asset " + slice + " to disk: " + filename)
  var imageData = [MSSliceExporter dataForRequest:slice]
  [imageData writeToFile:filename atomically:true]

}

function output( processResult ){

    //1. Create folders
    if( Util.folder_exist( Config.target_folder) ){
        Util.remove_folder( Config.target_folder)
    }
    Util.create_folders(
        [NSArray arrayWithObjects:
            Config.target_folder,Config.images_folder,Config.js_folder,Config.css_folder,nil])

    //2. Save inline script as single file
    // Single script structure : {comment:"",src:"",script:""}
    var scriptStr = "", scripts = Config.global_scripts.concat(processResult.scripts), scriptsCache={}
    Util.log( 'scripts length:' + scripts.length)
    Util.each( scripts, function(scriptObj){
        if( scriptObj.src && !scriptsCache[scriptObj.src]){
            var scriptNode = Dom.create('script').attr('src',scriptObj.src)
            processResult.dom.append(scriptNode)

            if( scriptObj.origin ){
                Util.copy( scriptObj.origin, scriptObj.src )
            }
            scriptsCache[scriptObj.src] = true
        }else{
            scriptStr += ['/* '+scriptObj.comment+' */',Util.script_to_string(scriptObj.script),''].join('\n')
        }
    })

    if( scriptStr ){
        var scriptSrc = Config.target_folder + "/index.js"
        processResult.dom.append( Dom.create('script').attr('src', scriptSrc ) )
        Util.save_file_from_string( scriptSrc, scriptStr);
    }

    //3. Save css as single file
    // Single style structure: {comment:"",href:"",style:{name:value}}
    var styleStr = "", styles = Config.global_styles.concat( processResult.styles),stylesCache = {}
    Util.each( styles, function(styleObj){
        if( styleObj.href && !scriptsCache[styleObj.href] ){
            processResult.dom.prepend(
                Dom.create('link').attr('href',styleObj.href).attr('type','text/css').attr('rel','stylesheet'))

            if( styleObj.origin ){
                Util.copy( styleObj.origin, styleObj.href )
            }
            stylesCache[styleObj.href] = true
        }else{
            styleStr += ['/* '+styleObj.comment+' */', Util.style_to_string(styleObj.style) ,''].join('\n')
        }
    })
    if( styleStr ){
        var styleSrc = Config.target_folder + "/index.css"
        processResult.dom.append(
            Dom.create('link').attr('href',styleSrc).attr('type','text/css').attr('rel','stylesheet'))

        Util.save_file_from_string( styleSrc, styleStr);
    }

    //4. Export images
    if( processResult.exportFiles ){
        Util.each( processResult.exportFiles, function( fileObj ){
//            Util.log("exporting "+fileObj.target)
            export_as_img( fileObj.layer, fileObj.target )
        })
    }

    //5. Save html
    Util.save_file_from_string(Config.target_folder + "/index.html", processResult.dom.outerHTML);
}


function main() {
    Util.execute(function() {
        var start = new Date().getTime()

        Util.log("###################")
        Util.log("### blade start ###")
        Util.log("###################")

        //1. Process layers
        var layers = [[doc currentPage] layers],
            processResult

        Util.each( layers, function( subLayer ){
            processResult = Binding.apply_bindings( subLayer );
        })

        //2. output files
//        Util.log( processResult.dom.outerHTML )
        output( processResult )

        var end = new Date().getTime()
        Util.log("Time used: " +(end - start))
        Util.log("###################")
        Util.log("###  blade end  ###")
        Util.log("###################")
        [doc showMessage:"Export Complete"]

    })
}

main();
