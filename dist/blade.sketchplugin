// Sketch blade (ctrl command b)
/**
 * Authorized by Jiamiu, all rights reserved.
 */

var environ = [[NSProcessInfo processInfo] environment],
    in_sandbox= (nil != [environ objectForKey:@"APP_SANDBOX_CONTAINER_ID"])

if(in_sandbox){
    print("We’re sandboxed: here be dragons")
}

AppSandbox = function(){ }
AppSandbox.prototype.authorize = function(path, callback){
    log("AppSandbox.authorize("+path+")")
    var success = false

    if (in_sandbox) {
        var url = [[[NSURL fileURLWithPath:path] URLByStandardizingPath] URLByResolvingSymlinksInPath],
        allowedUrl = false

        // Key for bookmark data:
        var bd_key = this.key_for_url(url)

        // this.clear_key(bd_key) // For debug only, this clears the key we're looking for :P

        // Bookmark
        var bookmark = this.get_data_for_key(bd_key)
        if(!bookmark){
            log("– No bookmark found, let's create one")
            var target = this.file_picker(url)
            bookmark = [target bookmarkDataWithOptions:NSURLBookmarkCreationWithSecurityScope
            includingResourceValuesForKeys:nil
            relativeToURL:nil
            error:{}]
            // Store bookmark
            this.set_data_for_key(bookmark,bd_key)
        } else {
            log("– Bookmark found")
        }
        log("  " + bookmark)

        // Thanks to @joethephish for this pointer (pun totally intended)
        var bookmarkDataIsStalePtr = MOPointer.alloc().init()
        var allowedURL = [NSURL URLByResolvingBookmarkData:bookmark
        options:NSURLBookmarkResolutionWithSecurityScope
        relativeToURL:nil
        bookmarkDataIsStale:bookmarkDataIsStalePtr
        error:{}]

        if(bookmarkDataIsStalePtr.value() != 0){
            log("— Bookmark data is stale")
            log(bookmarkDataIsStalePtr.value())
        }

        if(allowedURL) {
            success = true
        }
    } else {
        success = true
    }

    // [allowedUrl startAccessingSecurityScopedResource]
    callback.call(this,success)
    // [allowedUrl stopAccessingSecurityScopedResource]
}
AppSandbox.prototype.key_for_url = function(url){
    return "bd_" + [url absoluteString]
}
AppSandbox.prototype.clear_key = function(key){
    var def = [NSUserDefaults standardUserDefaults]
        [def setObject:nil forKey:key]
}
AppSandbox.prototype.file_picker = function(url){
    // Panel
    var openPanel = [NSOpenPanel openPanel]

        [openPanel setTitle:"Sketch Framer Authorization"]
    [openPanel setMessage:"Due to Apple's Sandboxing technology, Sketch needs your permission to write to this folder."];
    [openPanel setPrompt:"Authorize"];

    [openPanel setCanCreateDirectories:false]
    [openPanel setCanChooseFiles:true]
    [openPanel setCanChooseDirectories:true]
    [openPanel setAllowsMultipleSelection:false]
    [openPanel setShowsHiddenFiles:false]
    [openPanel setExtensionHidden:false]

    [openPanel setDirectoryURL:url]

    var openPanelButtonPressed = [openPanel runModal]
    if (openPanelButtonPressed == NSFileHandlingPanelOKButton) {
        allowedUrl = [openPanel URL]
    }
    return allowedUrl
}

AppSandbox.prototype.get_data_for_key = function(key){
    var def = [NSUserDefaults standardUserDefaults]
    return [def objectForKey:key]
}
AppSandbox.prototype.set_data_for_key = function(data,key){
    var defaults = [NSUserDefaults standardUserDefaults],
        default_values = [NSMutableDictionary dictionary]

            [default_values setObject:data forKey:key]
    [defaults registerDefaults:default_values]
}
/**
 * Created by jiamiu on 14-5-19.
 */

var Config = Config || (function(){

    var document_path = [[doc fileURL] path].replace( /\/[^\/]+\.sketch$/,'\/'),
        document_name = [doc displayName].replace(".sketch",""),
        target_folder = document_path + document_name,
        home_folder = "/Users/" + NSUserName(),
        images_folder = target_folder + "/images",
        css_folder = target_folder + "/css",
        js_folder = target_folder + "/js",
        plugin_folder = sketch.scriptPath.replace(/\/blade.sketchplugin$/,'')


    return {
        document_path : document_path,
        document_name : document_name,
        target_folder : target_folder,
        images_folder : images_folder,
        home_folder : home_folder,
        js_folder : js_folder,
        css_folder : css_folder,
        plugin_folder : plugin_folder,
        global_scripts : [{
            comment : 'global script : jquery-2.1.1.min.js',
            origin : plugin_folder + '/blade/lib/jquery-2.1.1.min.js',
            src : js_folder + '/jquery-2.1.1.min.js'
        }],
        global_styles : [{
            comment : 'global reset',
            origin : plugin_folder + '/blade/lib/reset.css',
            href : css_folder + '/reset.css'
        }],
        export_img_ext : ".png",
        show_error : false

    }
})()


//This file is base on Sam Deane's code, see the original license below

// --------------------------------------------------------------------------
// Miscellaneous Sketch utilities.
//
//  Copyright 2014 Sam Deane, Elegant Chaos. All rights reserved.
//  This source code is distributed under the terms of Elegant Chaos's
//  liberal license: http://www.elegantchaos.com/license/liberal
// --------------------------------------------------------------------------


var Util = Util || (function() {
    var my = {},persistent,console

    // perform a come code inside a try/catch block, and log out the error if something goes wrong
    my.execute = function(block) {
        try
        {
            block();
        }
        catch (e)
        {
            my.log(e);
        }
    }



    // return the Sketch version number
    // (we fish this out of the main info dictionary for the application)
    my.version = function() {
        var items = my.versionComponents();

        var result = items[0] + "." + items[1];
        if (items[2] != 0)
            result += "." + items[2];

        return result;
    }

    // return the Sketch version number, split into three components
    // (we fish this out of the main info dictionary for the application)
    my.versionComponents = function() {
        var info = [[NSBundle mainBundle] infoDictionary];
        var items = [[(info["CFBundleShortVersionString"]) componentsSeparatedByString:"."] mutableCopy];

        while(items.length() < 3)
            [items addObject:"0"];

        return items;
    }

    // return the main Sketch version number (eg 2 in 2.4.3)
    my.majorVersion = function() {
        var items = my.versionComponents();

        return items[0];
    }

    // return the minor Sketch version number (eg 4 in 2.4.3)
    my.minorVersion = function() {
        var items = my.versionComponents();

        return items[1];
    }

    // return the fix Sketch version number (eg 3 in 2.4.3)
    my.fixVersion = function() {
        var items = my.versionComponents();

        return items[2];
    }

    // return the exact Sketch build number
    // (we fish this out of the main info dictionary for the application)
    my.buildNumber = function() {
        var info = [[NSBundle mainBundle] infoDictionary];
        var result = info["CFBundleVersion"];

        return result;
    }

    // perform an action (in the way that a menu or button typically does)
    // what we're doing here is sending a command (an Objective-C method call)
    // down a chain of objects (the current window,
    // the current document, the application, etc) until one responds
    my.sendAction = function(commandToPerform) {
        try {
            [NSApp sendAction:commandToPerform to:nil from:doc]
        } catch(e) {
            my.log(e)
        }
    };

    // safe implementation of selection, which checks for it being nil
    // (which it can be before the user first selected anything)
    my.selection = function() {
        var selection = doc.selectedLayers();
        if (selection == null) {
            selection = [[NSArray alloc] init]
        }

        return selection;
    };

    // return a persistent window
    // this will make the window the first time it's called, but return the
    // same window next time (even if the next time is during a later execution of the script)
    my.persistentWindow = function(title, persistName, level, setup) {
        var window = persistent[persistName];
        if (window == null) {
            window = my.makeWindow(title, persistName, level, setup);
            persistent[persistName] = window;
        }

        return window;
    }

    // return a persistent panel
    // this will make the window the first time it's called, but return the
    // same window next time (even if the next time is during a later execution of the script)
    my.persistentPanel = function(title, persistName, setup) {
        var window = persistent[persistName];
        if (window == null) {
            window = my.makePanel(title, persistName, setup);
            persistent[persistName] = window;
        }

        return window;
    }

    // make a new window
    // this uses native Cocoa code to create a new window object, and set up various properties on it
    // for more details on NSWindow, see https://developer.apple.com/library/mac/documentation/cocoa/reference/applicationkit/classes/NSWindow_Class/Reference/Reference.html
    my.makeWindow = function(title, autosave, level, setup) {
        var frame = NSMakeRect(0,0,512,128);
        var mask = NSTitledWindowMask + NSClosableWindowMask + NSMiniaturizableWindowMask + NSResizableWindowMask;
        var window = [[NSWindow alloc] initWithContentRect:frame styleMask:mask backing:NSBackingStoreBuffered defer:true];
        window.title = title;
        window.level = level;
        [window setFrameAutosaveName:autosave];

        setup(window);

        [window setReleasedWhenClosed:false];
        [window makeKeyAndOrderFront:nil];

        return window;
    }

    // make a new panel
    // this uses native Cocoa code to create a new panel object, and set up various properties on it
    // for more details on NSPanel, see https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSPanel_Class/Reference/Reference.html
    my.makePanel = function(title, autosave, setup) {
        var frame = NSMakeRect(0,0,512,128);
        var mask = NSTitledWindowMask + NSClosableWindowMask + NSMiniaturizableWindowMask + NSResizableWindowMask + NSUtilityWindowMask;
        var window = [[NSPanel alloc] initWithContentRect:frame styleMask:mask backing:NSBackingStoreBuffered defer:true];
        window.title = title;
        window.floatingPanel = true;
        [window setFrameAutosaveName:autosave];

        setup(window);

        [window setReleasedWhenClosed:false];
        [window makeKeyAndOrderFront:nil];

        return window;
    }

    // make a new log window
    // we use Cocoa here to create a native window, and then we create a scrollview+textview combination
    // as the context, which gives us a scrolling text field
    // as luck would have it, Apple have some documentation describing this process:
    // https://developer.apple.com/library/mac/documentation/cocoa/conceptual/TextUILayer/Tasks/TextInScrollView.html#//apple_ref/doc/uid/20000938-CJBBIAAF
    my.logWindow = function() {
        var window = my.persistentPanel("Console", "LogWindow", function(window) {
            var scrollview = [[NSScrollView alloc] initWithFrame:[[window contentView] frame]];
            var contentSize = [scrollview contentSize];

            [scrollview setBorderType:NSNoBorder];
            [scrollview setHasVerticalScroller:true];
            [scrollview setHasHorizontalScroller:true];
            [scrollview setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];

            var FLT_MAX = 3.40282347e+38;
            var view = [[NSTextView alloc] initWithFrame:NSMakeRect(0, 0, contentSize.width, contentSize.height)];
            [view setMinSize:NSMakeSize(0.0, contentSize.height)];
            [view setMaxSize:NSMakeSize(FLT_MAX, FLT_MAX)];
            [view setVerticallyResizable:true];
            [view setHorizontallyResizable:true];
            [view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
            [[view textContainer] setContainerSize:NSMakeSize(FLT_MAX, FLT_MAX)];
            [[view textContainer] setWidthTracksTextView:false];

            [scrollview setDocumentView:view];
            [window setContentView:scrollview];
            [window makeFirstResponder:view];
        });

        return window;
    };

    // log something to our console window
    // we set the window up first if necessary, then
    // append the log message to the bottom of it and scroll the new line into view
    my.log = function(message) {
        if( !Config.show_error ){
            return
        }else{
            //first time
            if( !persistent ){
                persistent = [[NSThread mainThread] threadDictionary]
                console = persistent["console"]
            }

            if( arguments.length !== 1 ){
                message = Array.prototype.join.call( arguments, ", " )
            }

            var logWindow = my.logWindow();
            [logWindow makeKeyAndOrderFront:nil];

            var text = message;
            //var text = JSON.stringify(message);

            view = [[logWindow contentView] documentView];
            if (console == null)
                console = "";

            var now = new Date();
            var time = now.toLocaleTimeString().split(" ")[0];
            console = console + time + " " + text + "\n";
            [view setString:console];
            log(text);
            persistent["console"] = console;
            [view scrollRangeToVisible: NSMakeRange(view.string.length, 0)];
        }
    };

    my.launch = function(cmd, arguments) {
        var task = [[NSTask alloc] init];
        [task setLaunchPath:cmd];

        if (arguments)
            [task setArguments:arguments];

        var pipe = [NSPipe pipe];
        [task setStandardOutput: pipe];

        var file = [pipe fileHandleForReading];

        [task launch];

        var data = [file readDataToEndOfFile];
        var output = [[NSString alloc] initWithData: data encoding:NSUTF8StringEncoding];

        log(output);
    };

    my.save_file_from_string = function(filename, fileString) {
        new AppSandbox().authorize( Config.home_folder, function() {
            var path = [@"" stringByAppendingString:filename],
            str = [@"" stringByAppendingString:fileString];
//            var str = [[[NSString alloc] initWithString:fileString] autorelease]

//            fileString = null

            [str writeToFile:path atomically:true encoding:NSUTF8StringEncoding error:null];
        })
    }

    var file_manager = [NSFileManager defaultManager]

    my.create_folders =function ( folders ){
        new AppSandbox().authorize( Config.home_folder, function(){
            var i = [folders count] - 1
            for( ; i >-1 ;i-- ){
                [file_manager createDirectoryAtPath:[folders objectAtIndex:i] withIntermediateDirectories:true attributes:nil error:nil];
            }
        })
    }

    my.remove_folder = function( folder ){
        Util.log("removing file at :"+folder)
            [file_manager removeItemAtPath:folder error:nil]
    }

    my.folder_exist = function( folder ){
        return [file_manager fileExistsAtPath:folder]
    }

    my.copy = function ( org, tar ){
        Util.log('copy file:' )
        Util.log( 'from: ' + org )
        Util.log( 'to  : ' + tar )

        if( [file_manager fileExistsAtPath:org]){
            [file_manager copyItemAtPath:org toPath:tar error:nil];
        }else{
            Util.log('cannot copy,file not exist: '+org)
        }
    }

    my.uniq = (function(){
        var cache = {}

        return function( str ){

            str = str ? str.replace("-","_") : 'noname'

            if( !cache[str] ){
                cache[str] = 1
                return str
            }else{
                cache[str] += 1
                return str + "-" + String(cache[str])
            }
        }
    })()

    var fontManager = [NSFontManager sharedFontManager]

    my.fontWeight = function( font ){
        return fontManager.weightOfFont(font)
    }

    my.toRGBA = function( color ){
        return 'rgba(' + String( color ).replace(/[\(\)]/g,'').split(' ').map(function(v){
            var t = v.split(":"),type = t[0],value=t[1]
            if( type !== 'a' ){
                return Math.round( Number(value) * 256)
            }
            return Number(value)
        }).join(',')+')'
    }

    my.style_to_string = function( styleObj ){
        return join( map( styleObj, function( styles ){
            return join( styles, ":",';\n')
        }), ' {\n', '\n}\n') + '\n}'
    }

    function join( obj, kvSplitor, itemSplitor ){
        if( typeof obj !== 'object') return false

        return  values( map( obj, function(v,k){
            return k+kvSplitor+v
        })).join( itemSplitor )
    }

    function map( obj, cb ){
        if( Object.prototype.toString.call(obj) == '[object Array]'){
            return obj.map(cb)
        }else if( typeof obj == 'object' ){
            var output = {}
            for( var i in obj ){
                if( obj.hasOwnProperty(i) && typeof obj[i] !== 'function' ) {
                    output[i] = cb(obj[i], i)
                }
            }
            return output
        }

        return false
    }

    function values( obj ) {
        var _values = []

        for( var i in obj ){
            if( obj.hasOwnProperty(i) && typeof obj[i] !== 'function' ) {
                _values.push( obj[i] )
            }
        }
        return _values
    }

    function in_array( array, item ){
        var found = false
        for( var i in array ){
            if( item == array[i] ){
                found = true
                break
            }
        }
        return found
    }

    function each( obj, iterator ){
        var i,length

        if( obj.count && obj.className ){
            length = [obj count]

            for( i=0;i<length;i++){
                iterator( [obj objectAtIndex:i], i)
            }
        }else if( Object.prototype.toString.call( obj) == '[object Array]'){
            length = obj.length
            for( i=0;i<length;i++){
                iterator( obj[i],i)
            }
        }else if( typeof obj == 'object'){
            for( i in obj ){
                iterator( obj[i], i)
            }
        }else{
            Util.log("cannot iterator this obj of "+ (obj.className ? obj.className() : (typeof obj)))
        }
    }

    function extend( tar, src ){
        each( src, function( v,k){
            if( Object.prototype.toString.call( v) == '[object Object]'){
                tar[k] = {}
                extend( tar[k], src[k])
            }else if( Object.prototype.toString.call( v) == '[object Array]'){
                tar[k] = []
                extend( tar[k], src[k])
            }else{
                tar[k] = src[k]
            }
        })

        return tar
    }

    function wrap_script( script ){
        if( typeof script == 'object'){
            var arr = script
            for( var i in arr ){
                if( typeof arr[i] == 'function' ){
                    arr[i] = wrap_execute_imediate( String(arr[i] ))
                }
            }
            script = arr.join(';\n')
        }

        return ';(function(){\n' + script + '\n})();\n'
    }

    function render_variables( vars ){
        var output = []
        for( var varName in vars ){
            if( typeof vars[varName] == 'object') {
                //object or array
                output.push(varName + '=' + JSON.stringify(vars[varName]))
            }else if( typeof vars[varName] == 'string'){
                //string
                output.push(varName + '="' + vars[varName]+'"')
            }else{
                //undefined bool number
                output.push( varName + '=' + String(vars[varName]) )
            }
        }
        return "var "+output.join(',')
    }

    function wrap_execute_imediate( functionStr ){
        return ';(' + functionStr +')();\n'
    }

    function script_to_string( scriptObj ){
        return wrap_script([render_variables(scriptObj.vars),scriptObj.body])
    }

    my.join = join
    my.map = map
    my.values = values
    my.in_array = in_array
    my.each = each
    my.extend = extend
    my.wrap_script = wrap_script
    my.render_variables = render_variables
    my.script_to_string =script_to_string

    return my;
}());

/**
 * Created by jiamiu on 14-5-19.
 */

var Dom = Dom || (function(){


    function E( tag ){
        this.tagName= tag || ''
        this.childNodes = []
        this.parentNode = null
        this.innerHTML = ''
        this.id = null
        this.classList = []
        this.style = {}
        this.datas = {}
        this.attrs = {}
    }

    E.prototype.append = function( e ){
        this.childNodes.push(e)
        e.parentNode = this
        return this
    }

    E.prototype.prepend = function( e ){
        this.childNodes.unshift(e)
        e.parentNode = this
        return this
    }

    E.prototype.data = function( name, data ){
        if( data ){
            this.datas[name] = data
            return this
        }else{
            return this.datas[name]
        }
    }

    E.prototype.attr = function( name, data ){
        if( data ){
            this.attrs[name] = data
            return this
        }else{
            return this.attrs[name]
        }
    }

    E.prototype.css = function( name, style ){
        if( style ){
            this.style[name] = style
            return this
        }else{
            return this.style[name]
        }

    }

    E.prototype.find = function( queryString ){
        if( this.childNodes.length == 0) return;

        var output = [],queryArr = queryString.split(" "),
            currentQuery = queryArr.shift()

        Util.each( this.childNodes,function( child){

            if( child.match( currentQuery )){

                if( queryArr.length == 0 ){
                    output.push( child )
                }else{
                    output = output.concat( child.find( queryArr.join(" ")))
                }
            }
        })
        if( output.length !== 0 ){

        }
        return output

    }

    E.prototype.match = function( queryString ){
        var regSelectors = new RegExp('[#\\.\\[][\\w\\d_-]+(\\]|(?=[#\\.\\[])|$)','g'),
            regId = new RegExp('^#'),
            regClass = new RegExp('^\\.'),
            regAttr = new RegExp('^\\['),
            selectors = queryString.match( regSelectors )
        if( selectors ){
            var selector, i, j,found

            for( i in selectors ){
                selector = selectors[i]
                if( regId.test(selector) && this.attr('id') != selector.substr(1) ) return false

                if( regClass.test( selector) ){
                    found = false
                    for( j in this.classList){
                        if( this.classList[j] == selector.substr(1) ){
                            found = true;
                            break;
                        }
                    }
                    if( !found ) return false
                }

                if( regAttr.test( selector) ){
                    found = false
                    for( j in this.attrs ){
                        if( this.attrs[j] == selector.substr(1, selector.length-2)){
                            found = true;
                            break;
                        }
                    }
                    if( !found ) return false
                }
            }
        }

        return true
    }

    E.prototype.addClass = function( className ){
        this.classList.push( className)
        return this
    }

//    E.prototype.outerHTML = function(){
//
//        var selfClose = ['input','img','textarea','link']
//
//        if( selfClose.indexOf(this.tagName ) != -1 ){
//            return '<' + generate_tag_head(this) + ' />'
//        }else{
//            if( this.childNodes.length == 0 ){
//                return '<' + generate_tag_head(this) + ' >' + this.innerHTML + '</'+this.tagName + '>'
//            }else{
//
//                var childHTMl = this.childNodes.map(function( child ){
//                    return child.outerHTML()
//                }).join('')
//
//                return  '<' + generate_tag_head(this) + ' >' + childHTMl + '</'+this.tagName + '>'
//            }
//
//        }
//    }

    Object.defineProperty(E.prototype,"outerHTML",{
        get : function(){
            var selfClose = ['input','img','textarea','link']

            if( selfClose.indexOf(this.tagName ) != -1 ){
                return '<' + generate_tag_head(this) + ' />'
            }else{
                if( this.childNodes.length == 0 ){

                    return '<' + generate_tag_head(this) + ' >' + this.innerHTML + '</'+this.tagName + '>'
//                    var output ='<' + generate_tag_head(this) + ' >' + this.innerHTML + '</'+this.tagName + '>'
//
//                    return [[NSString alloc] initWithString :output]
                }else{

                    var childHTMl = this.childNodes.map(function( child ){
                        return child.outerHTML
                    }).join('')

                    return  '<' + generate_tag_head(this) + ' >' + childHTMl + '</'+this.tagName + '>'

//                      var head = '<' + generate_tag_head(this) + ' >',
//                          output = [NSMutableString stringWithString:head];
//
//                    for( var i in this.childNodes ){
//                        var childOutput = this.childNodes[i].outerHTML
//                        [output appendString:childOutput]
//                        Util.log( childOutput, output)
//                        [childOutput release]
//                    }
//
//                    return [output appendString:@" >"]
                }

            }
        }
    })

    function generate_tag_head( el ){
        var items = [
            el.tagName
        ]

        if( Util.values(el.style).length ){
            items.push('style="' + Util.join(el.style,":",";") + '"')
        }

        if( el.id ){
            items.push( 'id="' + el.id +'"')
        }

        if( Util.values(el.datas).length ){
            items = items.concat( Util.values( Util.map( el.datas, function(v, k){ return 'data-'+k+'="'+v+'"'})))
        }

        if( Util.values(el.attrs).length ){
            items = items.concat( Util.values( Util.map( el.attrs, function(v, k){ return k+'="'+v+'"'})))
        }

        if( el.classList.length ){
            items.push('class="' + el.classList.join(' ')+'"')
        }
//        Util.log( JSON.stringify(items ) )
        return items.join(" ")
    }

    function create(tag){
        return new E(tag)
    }

    return {
        create : create
    }
})()






/**
 * Created by jiamiu on 14-5-19.
 */

var Binding = Binding || (function(){
    var ObjectId = 0

    var bindingImp = {}

    /**
     * @param {string} name
     * @param {function|object} handler - This parameter is just like AngularJS's directive definition object.
     *        Here is an example when pass an object:
     *        {
     *          compose : function(){
     *              // some code here to perform dom transformation
     *          },
     *          link : function(){
     *              //code here to add script
     *          }
     *        }
     *        When pass a function as parameter, the function will be used as `link` function.
     */
    function registry(name, handler){
        if( bindingImp[name] ){
            Util.log( 'you are overwriting binding: ' + name)
        }

        if( typeof handler == 'function'){
            handler = { compose:noop, link : handler }
        }else if( typeof handler =='object'){
            if( !handler.compose ){
                handler.compose = noop
            }
            if( !handler.link ){
                handler.link = noop
            }

        }else{
            Util.log( 'Unacceptable handler for '+name)
            return
        }

        handler.inited = false

        bindingImp[name] = handler

    }

    /**
     * Call all bindings in this layer to do their job.
     *
     * @param {sketch layer} layer
     * @param {object} parentOutputRef - This is a reference to hold process result.
     * @param {object} [bindings] - If bindings was specified, then we will not get from layer name.
     *
     * @return {object|undefined} parentOutputRef - notice that we will always return parentOutputRef.
     */
    function apply_bindings( layer, parentOutputRef, bindings ){
//        Util.log("apply_bindings for "+ layer.name()+" : "+get_kind(layer) + " : " + layer.className() )
        if( !is_layer( layer) ){
            Util.log("please pass a layer as first argument.")
            return
        }

        if( !parentOutputRef ){
            parentOutputRef = {
                dom : Dom.create('body'),
                scripts : [],
                styles : [],
                exportFiles : []
            }

        }

        var outputRef = {
                dom : Dom.create(),
                scripts : [],
                styles : [],
                exportFiles : []
            },
            stopAutoApplyBindingForChildren = false

        // Dom generator may attach scripts for special dom,
        // so we need to pass the output reference as parameter
        generate_dom_by_kind( layer, outputRef )

        //we must append the dom here so compose function can access parent node.
        //notice you can only use dom functions to modify dom, or you will loss reference.
        parentOutputRef.dom.append( outputRef.dom )

        bindings = bindings || get_bindings(layer.name())

        // apply default binding only if no binding specified
        if( !bindings || !Util.values( bindings).length ){
            bindingImp['default']['link']( layer, null,  outputRef )
        }else{
            //compose it first and load external scripts and styles
            Util.each( bindings, function( bindingArgs, bindingName ){
                //load scripts and styles
                if( !bindingImp[bindingName] ){
                    Util.log('Unknown binding: '+ bindingName)
                    return
                }

                if( !bindingImp[bindingName].inited ){
                    if( bindingImp[bindingName]['init'] ){
                        bindingImp[bindingName]['init']()
                    }

                    if( bindingImp[bindingName]['scripts'] ){
                        Util.log("find script for "+bindingName)
                        outputRef.scripts = outputRef.scripts.concat( bindingImp[bindingName]['scripts'] )
                    }
                    //load styles
                    if( bindingImp[bindingName]['styles'] ){
                        outputRef.styles = outputRef.styles.concat( bindingImp[bindingName]['styles'] )
                    }

                    bindingImp[bindingName].inited = true

                }

                if( bindingImp[bindingName].stopAutoApplyBindingForChildren ){
                    Util.log(bindingName+' has stopAutoApplyBindingForChildren')
                    stopAutoApplyBindingForChildren = true
                }

                //compose
                bindingImp[bindingName]['compose']( layer, bindingArgs, outputRef )

                //mark it
                outputRef.dom.attr('binding-'+bindingName,String(bindingArgs))
            })



            Util.log("get bindings"+JSON.stringify( bindings))

            //link it
            Util.each( bindings, function( bindingArgs, bindingName ){
                Util.log("calling binding link function " +  bindingName)
                if( bindingImp[bindingName] ){
                    bindingImp[bindingName]['link']( layer, bindingArgs, outputRef )
                }else{
                    Util.log('Unknown binding: '+ bindingName)
                }
            })
        }

        if( is_folder(layer) && !stopAutoApplyBindingForChildren){
            var layers= [layer layers]
            Util.each( layers, function( subLayer){
                apply_bindings( subLayer, outputRef )
            })
        }

        parentOutputRef.scripts = parentOutputRef.scripts.concat( outputRef.scripts )
        parentOutputRef.styles = parentOutputRef.styles.concat( outputRef.styles )
        parentOutputRef.exportFiles = parentOutputRef.exportFiles.concat( outputRef.exportFiles )

        return parentOutputRef
    }

    function get_bindings( name ){
        var matches = name.match(/\[([\w\d%_,-:=]*)\]/g),
            bindings = {}

        if( matches ){
            for( var i in matches ){
                var tmp = matches[i].substring(1,matches[i].length-1).split("="),
                    bindingName = tmp[0],
                    bindingArgs = tmp[1] ? tmp[1].split(",") : [true]

                bindings[bindingName] = bindingArgs
            }
        }
        return bindings
    }


    var domGenerators = {}

    function register_dom_generator(name, handler){
        domGenerators[name] = (typeof handler =='object') ? handler : {dom:handler,css:noop}
    }

    function generate_dom_by_kind( layer, outputRef ){

        var kind = get_kind( layer),generatorName = domGenerators[kind]? kind : 'default'
        Util.log("generate dom for " + kind)

        domGenerators[generatorName].dom( layer, outputRef )
        domGenerators[generatorName].css( outputRef.dom, layer)

        outputRef.dom.data('sketch-kind', kind )
        outputRef.dom.data('title', layer.name())
    }

    function setup_rect_for_dom( dom, layer ){
        dom.style.position = "absolute"
        if( get_kind(layer.parentGroup()) == 'LayerGroup' ){
            dom.style.left = layer.absoluteRect().rulerX() - layer.parentGroup().absoluteRect().rulerX()
            dom.style.top = layer.absoluteRect().rulerY() - layer.parentGroup().absoluteRect().rulerY()
        }else{
            dom.style.left = layer.absoluteRect().rulerX()
            dom.style.top = layer.absoluteRect().rulerY()
        }

        dom.style.width =  layer.absoluteRect().width()
        dom.style.height =  layer.absoluteRect().height()
        if( !layer.isVisible()){
            dom.css('display','none')
        }
    }

    function sanitize_filename(name){
        return name.replace(/(\s|:|\/)/g ,"_").replace(/__/g,"_").replace("*","").replace("+","").replace("@@hidden","");
    }



    function get_kind( layer) {
        var _class = layer.className(),
            _kind = "Other",
            _path;
        if ( _class == "MSTextLayer" ) { // text layer
            _kind = "Text";
        } else if ( _class == "MSArtboardGroup") { // text layer
            _kind = "Artboard"
        } else if ( _class == "MSSliceLayer") { // text layer
            _kind = "Slice";
        } else if (_class == "MSBitmapLayer" ) { // text layer
            _kind = "Bitmap";
        } else if (_class == "MSShapeGroup" ) { // group layer or shape layer
            if( layer.children().count() == 2 ){
                var _lay = layer.children()[0],
                    _class1 = _lay.className().toString(),
                    _isSpecificShape1 = /^MS\w*Shape$/.test(_class1)


                if (_class1 == "MSShapePathLayer") { // shape path
                    _path = _lay.path(); // get the path on the layer
                    if (_path.isLine()) { // check with the path method
                        _kind = "Line";
                    }else{
                        _kind = "Vector"
                    }
                } else if (_isSpecificShape1) {
                    _kind = _class1.replace("MS", "").replace("Shape", "");
                }
            }else{
                _kind = "ShapeGroup"
            }

        }else if( _class== "MSLayerGroup" ){
            _kind  = "LayerGroup"
        }

        return _kind;
    }

    function generate_id(){
        return '_object_' + ObjectId++
    }

    function concat_child_process_result( current, child){
        if( child.dom ){
            current.dom.append(child.dom)
        }
        current.scripts = current.scripts.concat( child.scripts )
        current.styles = current.styles.concat( child.styles)
    }

    function get_styles( layer ){
        var styles = {},
            borders = layer.style.borders().array(),
            fills = layer.style.fills().array(),
            shadows =layer.style.shadows().array(),
            innerShadows =layer.style.innerShadows().array()

        //TODO
        return styles
    }



    function is_group(layer) {
        return [layer isMemberOfClass:[MSLayerGroup class]] || [layer isMemberOfClass:[MSArtboardGroup class]]
    }

    function is_folder( layer ){
        return layer.className().toString() == 'MSLayerGroup'
    }

    function is_array( layer ){
        return [layer isMemberOfClass:[MSArray class]]

    }

    function is_layer( layer ){
        if( !layer.className ) return false

        var classes = ['MSLayerGroup','MSShapeGroup','MSArtboardGroup','MSTextLayer','MSBitmapLayer','MSShapePathLayer','MSShapePath']
        return Util.in_array( classes, layer.className().toString() )
    }



    function noop(){}

    return {
        apply_bindings : apply_bindings,
        registry : registry,
        get_bindings : get_bindings,
        generate_dom_by_kind : generate_dom_by_kind,
        generate_id : generate_id,
        concat_child_process_result : concat_child_process_result,
        register_dom_generator : register_dom_generator,
        sanitize_filename : sanitize_filename,
        is_group : is_group,
        is_array : is_array,
        is_folder : is_folder,
        get_kind : get_kind,
        setup_rect_for_dom:setup_rect_for_dom,
        get_styles : get_styles,
        domGenerators : domGenerators
    }
})()



/**
 * Created by jiamiu on 14-5-21.
 */

function handler_export( layer, outputRef){
    var dom = Dom.create('img'),
        filename = Config.images_folder + "/" + Util.uniq( Binding.sanitize_filename(layer.name()) ),
        ext = Config.export_img_ext,
        src = filename.replace(Config.target_folder+"/",'') + ext


    dom.attr('src', src)
    outputRef.exportFiles.push( {layer : layer, target : filename+ext})
    return dom
}

Binding.register_dom_generator('LayerGroup',function(layer, outputRef){
    outputRef.dom =  Dom.create('div')
    Binding.setup_rect_for_dom( outputRef.dom, layer )

})

Binding.register_dom_generator('Text',{
    dom :function(layer, outputRef){

        var needExport = false
        if( layer.style().borders().array().count() !== 0
            || layer.style().fills().array().count()
            ){
            needExport = true
        }


        if( !needExport ){
            var dom = Dom.create('p')
            //TODO browsers has different strategy to calculate the width of space with Sketch.
            dom.innerHTML = layer.stringValue()
        }else{
            var dom = handler_export(layer, outputRef)
        }

        Binding.setup_rect_for_dom( dom, layer )
        outputRef.dom = dom



    },
    css :function(dom, layer){
        if( dom.tagName == 'img' ) return

        Util.extend( dom.style,{
            "font-size" : layer.fontSize(),
            "letter-spacing" : layer.characterSpacing(),
            "line-height" :  layer.lineSpacing() + 'px'
        })

        dom.style['color'] = 'rgba(' + String(layer.textColor()).replace(/[\(\)]/g,'').split(' ').map(function(v){
            var t = v.split(":"),type = t[0],value=t[1]
            if( type !== 'a' ){
                return Math.round( Number(value) * 256)
            }
            return Number(value)
        }).join(',')+')'


        var align = ['left','right','center','justify']
        dom.style['text-align'] = align[layer.textAlignment()] ? align[layer.textAlignment()] : 'inherit'

        //fix browser and Sketch line-height diffrence
        dom.style['margin-top'] = (parseInt( dom.style['line-height'] ) - parseInt( layer.fontSize() ) ) + "px"

        dom.style['white-space'] = 'pre'
        dom.style['word-break'] = 'break-word'

        //NOT SUPPORT font-style NOW
        var font = layer.font()
        dom.style['font-family'] = "'"+font.familyName()+"'"
        dom.style['font-weight'] = Number(Util.fontWeight( font) ) *100

        //TODO: deal with font fill

    }
})

//due to Sketch api issue, we can not generate div for every Rectangle
Binding.register_dom_generator('Rect',{
    dom:function(layer, outputRef){
        //Rectangle is the shape which will not export as a image but generate a div.

        var needExport = false,
            borders = layer.style().borders().array(),
            fills = layer.style().fills().array(),
            i= 0,fillsCount = fills.count(),
            dom

        if( borders.count() > 1 ){
            Util.log("borders count > 1")
            needExport = true
        }

        for( ;i<fillsCount; i++){
            if( fills[i].fillType == 4  ){
                Util.log("fillType == 4")

                needExport= true;
                break;
            }
        }

        if( needExport ){
            dom = handler_export(layer, outputRef)

        }else{
            dom = Dom.create('div')
        }

        Binding.setup_rect_for_dom( dom, layer )
        outputRef.dom = dom
    },
    css : function(dom, layer) {
        if( dom.tagName == "img") return

        var borders = layer.style().borders().array(),
            fills = layer.style().fills().array(),
            shadows = layer.style().shadows(),
            innerShadows = layer.style().innerShadows()

        if( borders.count() == 1 && borders.objectAtIndex(0).isEnabled()){
            dom.style['border'] = borders.objectAtIndex(0).thickness() +"px solid " + Util.toRGBA( borders.objectAtIndex(0).color() )
        }
        if( fills.count() > 0 ){
            var backgrounds = []
            Util.each( fills, function(fill){
                if( fill.isEnabled() == 1 ){
                    backgrounds.push( Util.toRGBA( fill.color()))
                }
            })
            backgrounds.length && ( dom.style['background'] = backgrounds.join(',') )
        }

        if( shadows.count() + innerShadows.count() > 0 ){
            var shadowStyles = []
            Util.each( shadows, function( shadow){
                if( !shadow.isEnabled() ) return

                shadowStyles.push(
                        [shadow.offsetX(),shadow.offsetY(),shadow.blurRadius(),shadow.spread()].map(function(i){
                            return i+"px"
                        }).join(' ') + " " + Util.toRGBA( shadow.color())
                )
            })

            Util.each( innerShadows, function( innerShadow){
                if( !innerShadow.isEnabled() ) return ;

                shadowStyles.push(
                        "inset " + [innerShadow.offsetX(),innerShadow.offsetY(),innerShadow.blurRadius(),innerShadow.spread()].map(function(i){
                        return i+"px"
                    }).join(' ') + " " + Util.toRGBA( innerShadow.color())
                )
            })
            shadowStyles.length && ( dom.style['box-shadow'] = shadowStyles.join(','))
        }
    }
})

Binding.register_dom_generator('Bitmap1',function(layer,outputRef){
    var dom = handler_export(layer, outputRef)


    Binding.setup_rect_for_dom( dom, layer )
    outputRef.dom = dom
})


Binding.register_dom_generator('default',function(layer,outputRef){
    var dom = handler_export(layer, outputRef)

    Binding.setup_rect_for_dom( dom, layer )
    outputRef.dom = dom
})
/**
 * Created by jiamiu on 14-6-5.
 */

Binding.registry('a',{
    compose: function(  layer, args, outputRef  ){
        var dom = outputRef.dom,
            id = dom.attr('id') || Binding.generate_id(),
            href = args.pop()


        dom.tagName = 'a'

        if( !dom.attr('id') ){
            dom.attr('id', id)
        }

        //due to JSTalk RegExp issue
        if( href.substr(0,6) !== "http:/" || href.substr(0,6) !=="https:"){
            href = 'http:\/\/' +href
        }

        dom.attr('href', href)

        var style = {
            comment : "dynamically generated for tag a",
            style : {}
        }
        style.style['#'+id] = {}
        style.style['#'+id+":hover"] = {}

        if( Binding.get_kind( layer ) !== 'LayerGroup' ){
            Binding.domGenerators['Text'].css( dom, layer )
        }else{
            var layers = [layer layers]

            Util.each( layers, function( subLayer){

                var bindings = Binding.get_bindings(subLayer.name()),
                    binding = Util.values( bindings).pop(),
                    fakeDom,


                fakeDom = Dom.create('div')

                    //use generator to help use with css
                    Binding.domGenerators['Text'].css( fakeDom, subLayer )

                    if( !dom.innerHTML ){
                        dom.innerHTML = subLayer.stringValue()
                    }

                Util.extend(style.style['#'+id+(binding?':'+binding:'')] , fakeDom.style)
            })
        }

        // set position for text
        dom.style['cursor'] = 'pointer'
        dom.style['text-decoration'] = 'none'
        outputRef.dom = dom
    },
    //we will take the children from here
    stopAutoApplyBindingForChildren : true
})
/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-6-5.
 */

Binding.registry('btn',{
    compose: function(  layer, args, outputRef  ){
        var dom = outputRef.dom,
            layers = [layer layers],
            id,textPosition={},rectPosition={}

        if( dom.attr('id') ){
            id = dom.attr('id')
        }else{
            id = Binding.generate_id()
            dom.attr('id', id)
        }

        dom.tagName = 'a'
        dom.attr('type','text')

        var style = {
            comment : "dynamically generated for button",
            style : {}
        }
        style.style['#'+id] = {}
        style.style['#'+id+":hover"] = {}

        Util.each( layers, function( subLayer){

            var bindings = Binding.get_bindings(subLayer.name()),
                fakeDom

            fakeDom = Dom.create('div')

            if( Binding.get_kind( subLayer) == 'Text'){
                //use generator to help use with css
                Binding.domGenerators['Text'].css( fakeDom, subLayer )

                if( !dom.innerHTML ){
                    dom.innerHTML = subLayer.stringValue()
                    textPosition.x = subLayer.absoluteRect().rulerX()
                    textPosition.y = subLayer.absoluteRect().rulerY()
                }

            }else if( Binding.get_kind(subLayer) == 'Rectangle'){
                Binding.domGenerators['Rect'].css( fakeDom, subLayer )

                outputRef.styles.push( style )

                if( !rectPosition.x ){
                    rectPosition.x = subLayer.absoluteRect().rulerX()
                    rectPosition.y = subLayer.absoluteRect().rulerY()
                }
            }

            Util.extend(style.style['#'+id+(bindings['hover']?':hover':'')] , fakeDom.style)

        })

        // set position for text
        dom.style['padding-top'] = String(textPosition.y - rectPosition.y) + 'px'
        dom.style['padding-left'] = String(textPosition.x - rectPosition.x) + 'px'
        dom.style['box-sizing'] = 'border-box'
        dom.style['cursor'] = 'pointer'
        dom.style['display'] = 'inline-block'
        outputRef.dom = dom
    },
    //we will take the children from here
    stopAutoApplyBindingForChildren : true
})
/**
 * Created by jiamiu on 14-5-19.
 */

Binding.registry('case',{
    scripts : [{
        'origin' : Config.plugin_folder + '/blade/bindings/case/binding-case.js',
        'src' : Config.js_folder +'/binding-case.js'
    }],
    styles:[{
        'origin' : Config.plugin_folder + '/blade/bindings/case/binding-case.css',
        'href' : Config.css_folder + '/binding-case.css'
    }],
    init: function(){
        /* this method will only be called when this binding first be used.*/
    },
    compose: function(  layer, args, outputRef  ){
        var controllerClass = 'binding-case-controller',
            caseClass = 'binding-case',
            casesClass = 'binding-cases',
            controllersClass= controllerClass + 's',
            controllersSelector = '['+controllersClass+']',
            bindings = Binding.get_bindings(layer.name()),
            id = bindings['id'] ? bindings['id'][0] : Binding.generate_id()


        //1. generator a controller for current case
        if( outputRef.dom.parentNode.find(controllersSelector).length ==0 ){
            outputRef.dom.parentNode.append(
                Dom.create('div').attr(controllersClass,controllersClass).addClass(controllersClass) )

            //give parent a class by the way
            outputRef.dom.parentNode.addClass(casesClass)
        }

        var controller = Dom.create('div')
            .attr('data-case-id',id)
            .attr(controllerClass,controllerClass)
            .addClass(controllerClass)
        controller.innerHTML = args[0]

        outputRef.dom.parentNode.find(controllersSelector)[0].append( controller )

        //2. dealing with current case
        if( !outputRef.dom.attr('id') ){
            outputRef.dom.attr('id',id)
        }
        outputRef.dom.addClass( caseClass)
    }
})
/**
 * Created by jiamiu on 14-6-9.
 */

Binding.registry('center',{
    /**
     *
     * @param layer
     * @param args Current support 'v' : vertical, 'h' : horizon, 'v,h' : both.
     * @param outputRef
     */
    link: function(  layer, args, outputRef  ){
        var dom = outputRef.dom,
            id = dom.attr('id') || Binding.generate_id(),
            type

        while( type = args.pop() ){
            if( type == 'h' ){

                dom.style['position'] = 'relative'
                dom.style['margin-left'] = 'auto'
                dom.style['margin-right'] = 'auto'

            }else if( type =='v' ){

                //use script

            }
        }

    }
})
/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-21.
 */

Binding.registry('default',function(  layer, args, outputRef  ){
    //we do nothing!
})
/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

Binding.registry('hover',function(  layer, args, outputRef  ){
//    if( !Binding.is_group( layer) ){
//        Util.log('[hover] :' + layer.name() +' is not group.')
//        return
//    }
//
//    //1.deal with current layer
//    var bindings = Binding.get_bindings(layer.name()),
//        id = bindings['id'] ? bindings['id'][0] : Binding.generate_id()
//
//
//    if( !outputRef.dom.attr('id') ){
//        outputRef.dom.attr('id',id)
//    }
//
//    //2.deal with children who has binding of [onHover]
//    var subIds = [],layers = [layer layers]
//    Util.each( layers, function( subLayer, i ){
//
//        var subBindings = Binding.get_bindings(subLayer.name()),
//            subId = subBindings['id'] ? subBindings['id'][0] : Binding.generate_id()
//
//        if( !subBindings['onHover'] ){
//            //normal layer
//            if( !outputRef.dom.childNodes[i] ){
//                Binding.apply_bindings( subLayer, outputRef )
//            }
//
//        }else{
//            delete subBindings['onHover']
//
//            //3.generate the children with rest bindings
//            Util.log("==sublayer : " + subLayer)
//
//            if( !outputRef.dom.childNodes[i] ){
//                Binding.apply_bindings( subLayer, outputRef , subBindings )
//            }
//
//            if( !outputRef.dom.childNodes[i].attr('id') ){
//                outputRef.dom.childNodes[i].attr('id',subId)
//            }
//
//            subIds.push(subId)
//
//            //4.output hover script
//            outputRef.scripts.push({
//                comment : 'hover script for '+layer.name(),
//                script :{
//                    vars : {id:id,subIds:subIds},
//                    body : function(){
//                        $.each(subIds,function(k,subId){
//                            $('#'+subId).hide()
//                        })
//
//                        $('#'+id).hover(function(){
//                            $.each(subIds,function(k,subId){
//                                $('#'+subId).show()
//                            })
//                        },function(){
//                            $.each(subIds,function(k,subId){
//                                $('#'+subId).hide()
//                            })
//                        })
//                    }
//                }
//            })
//        }
//
//    })

})
/**
 * Created by jiamiu on 14-5-19.
 */

Binding.registry('ignore',{
    stopAutoApplyBindingForChildren : true
})
/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-6-5.
 */

Binding.registry('text',{
    compose: function(  layer, args, outputRef  ){
        var dom = outputRef.dom,
            layers = [layer layers]

        dom.tagName = 'input'
        dom.attr('type','text')

        Util.each( layers, function( subLayer ){
            if( Binding.get_kind( subLayer) =='Text' ){
                dom.attr('placeholder', subLayer.stringValue() )
                dom.style['font-size'] = subLayer.fontSize()
                dom.style['color'] = Util.toRGBA(subLayer.textColor())

            }else if(Binding.get_kind( subLayer) =='Rectangle'){
                //get background and border
                var border = subLayer.style().borders().array()[0],
                    fill = subLayer.style().fills().array()[0]

                dom.style['border'] = [border.thickness(),'solid', Util.toRGBA(border.color())].join(' ')
                dom.style['background'] = Util.toRGBA(fill.color())

                dom.style['line-height']= dom.style['height'] + "px"
                dom.style['outline']= 'none'
                dom.style['box-sizing']= 'border-box'
                dom.style['padding']= '0 4px'
            }
        })


        outputRef.dom = dom
    },
    //we will take the children from here
    stopAutoApplyBindingForChildren : true
})
/**
 * Created by jiamiu on 14-5-19.
 */

/**
 * Created by jiamiu on 14-6-9.
 */

Binding.registry('width',{
    compose: function(  layer, args, outputRef  ){
        var dom = outputRef.dom,
            id = dom.attr('id') || Binding.generate_id(),
            width = args.pop()

        dom.style['width'] = width

    }
})



function export_as_img( layer, filename ){
  // Actual writing of asset
  var slice,
    rect = [layer rectByAccountingForStyleSize:[[layer absoluteRect] rect]]


  slice = [[MSSliceMaker slicesFromExportableLayer:layer inRect:rect] firstObject]
  slice.page = [[doc currentPage] copyLightweight]
  slice.format = "png"
  slice.scale = 2

//  Util.log("— writing asset " + slice + " to disk: " + filename)
  var imageData = [MSSliceExporter dataForRequest:slice]
  [imageData writeToFile:filename atomically:true]

}

function output( processResult ){

    //1. Create folders
    if( Util.folder_exist( Config.target_folder) ){
        Util.remove_folder( Config.target_folder)
    }
    Util.create_folders(
        [NSArray arrayWithObjects:
            Config.target_folder,Config.images_folder,Config.js_folder,Config.css_folder,nil])

    //2. Save inline script as single file
    // Single script structure : {comment:"",src:"",script:""}
    var scriptStr = "", scripts = Config.global_scripts.concat(processResult.scripts), scriptsCache={}
    Util.log( 'scripts length:' + scripts.length)
    Util.each( scripts, function(scriptObj){
        if( scriptObj.src && !scriptsCache[scriptObj.src]){
            var src = scriptObj.src.replace(Config.target_folder+'/',''),
                scriptNode = Dom.create('script').attr('src',src)
            processResult.dom.append(scriptNode)

            if( scriptObj.origin ){
                Util.copy( scriptObj.origin, scriptObj.src )
            }
            scriptsCache[scriptObj.src] = true
        }else{
            scriptStr += ['/* '+scriptObj.comment+' */',Util.script_to_string(scriptObj.script),''].join('\n')
        }
    })

    if( scriptStr ){
        var scriptSrc = Config.target_folder + "/index.js"
        processResult.dom.append( Dom.create('script').attr('src', 'index.js' ) )
        Util.save_file_from_string( scriptSrc, scriptStr);
    }

    //3. Save css as single file
    // Single style structure: {comment:"",href:"",style:{name:value}}
    var styleStr = "", styles = Config.global_styles.concat( processResult.styles),stylesCache = {}
    Util.each( styles, function(styleObj){
        if( styleObj.href && !scriptsCache[styleObj.href] ){
            var href = styleObj.href.replace( Config.target_folder+'/',''),
                linkDom = Dom.create('link').attr('href',href).attr('type','text/css').attr('rel','stylesheet')
            processResult.dom.prepend(linkDom)

            if( styleObj.origin ){
                Util.copy( styleObj.origin, styleObj.href )
            }
            stylesCache[styleObj.href] = true
        }else{
            styleStr += ['/* '+styleObj.comment+' */', Util.style_to_string(styleObj.style) ,''].join('\n')
        }
    })
    if( styleStr ){
        var styleSrc = Config.target_folder + "/index.css"
        processResult.dom.append(
            Dom.create('link').attr('href','index.css').attr('type','text/css').attr('rel','stylesheet'))

        Util.save_file_from_string( styleSrc, styleStr);
    }

    //4. Export images
    if( processResult.exportFiles ){
        Util.each( processResult.exportFiles, function( fileObj ){
//            Util.log("exporting "+fileObj.target)
            export_as_img( fileObj.layer, fileObj.target )
        })
    }

    //5. Save html
    Util.save_file_from_string(Config.target_folder + "/index.html", processResult.dom.outerHTML);
//    Util.save_file_from_string(Config.target_folder + "/index.html", processResult.dom.outerHTML());
}


function main() {
    Util.execute(function() {
        var start = new Date().getTime()

        Util.log("###################")
        Util.log("### blade start ###")
        Util.log("###################")

        //1. Process layers
        var layers = [[doc currentPage] layers],
            processResult

        Util.each( layers, function( subLayer ){
            processResult = Binding.apply_bindings( subLayer );
        })

        //2. output files
//        Util.log( processResult.dom.outerHTML )
        output( processResult )

        var end = new Date().getTime()
        Util.log("Time used: " +(end - start))
        Util.log("###################")
        Util.log("###  blade end  ###")
        Util.log("###################")
        [doc showMessage:"Export Complete"]

    })
}

main();